     -:     0:Source:../../../../../../../../../Keil/ARM/PACK/ARM/CMSIS-RTX/5.9.0/Source/rtx_thread.c
     -:     0:Graph:
     -:     0:Runs:1
     -:     0:Programs:1
     -:     1:/*
     -:     2: * Copyright (c) 2013-2023 Arm Limited. All rights reserved.
     -:     3: *
     -:     4: * SPDX-License-Identifier: Apache-2.0
     -:     5: *
     -:     6: * Licensed under the Apache License, Version 2.0 (the License); you may
     -:     7: * not use this file except in compliance with the License.
     -:     8: * You may obtain a copy of the License at
     -:     9: *
     -:    10: * www.apache.org/licenses/LICENSE-2.0
     -:    11: *
     -:    12: * Unless required by applicable law or agreed to in writing, software
     -:    13: * distributed under the License is distributed on an AS IS BASIS, WITHOUT
     -:    14: * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     -:    15: * See the License for the specific language governing permissions and
     -:    16: * limitations under the License.
     -:    17: *
     -:    18: * -----------------------------------------------------------------------------
     -:    19: *
     -:    20: * Project:     CMSIS-RTOS RTX
     -:    21: * Title:       Thread functions
     -:    22: *
     -:    23: * -----------------------------------------------------------------------------
     -:    24: */
     -:    25:
     -:    26:#include "rtx_lib.h"
     -:    27:
     -:    28:
     -:    29://  OS Runtime Object Memory Usage
     -:    30:#ifdef RTX_OBJ_MEM_USAGE
     -:    31:osRtxObjectMemUsage_t osRtxThreadMemUsage \
     -:    32:__attribute__((section(".data.os.thread.obj"))) =
     -:    33:{ 0U, 0U, 0U };
     -:    34:#endif
     -:    35:
     -:    36://  Runtime Class/Zone assignment table
     -:    37:#if defined(RTX_EXECUTION_ZONE) && defined(RTX_SAFETY_CLASS)
     -:    38:static uint8_t ThreadClassTable[64] __attribute__((section(".data.os"))) = { 0U };
     -:    39:#endif
     -:    40:
     -:    41:// Watchdog Alarm Flag
     -:    42:#if defined(RTX_THREAD_WATCHDOG) && defined(RTX_EXECUTION_ZONE)
     -:    43:static uint8_t WatchdogAlarmFlag __attribute__((section(".data.os"))) = 0U;
     -:    44:#endif
     -:    45:
     -:    46:
     -:    47://  ==== Helper functions ====
     -:    48:
     -:    49:/// Set Thread Flags.
     -:    50:/// \param[in]  thread          thread object.
     -:    51:/// \param[in]  flags           specifies the flags to set.
     -:    52:/// \return thread flags after setting.
     -:    53:static uint32_t ThreadFlagsSet (os_thread_t *thread, uint32_t flags) {
     -:    54:#if (EXCLUSIVE_ACCESS == 0)
     -:    55:  uint32_t primask = __get_PRIMASK();
     -:    56:#endif
     -:    57:  uint32_t thread_flags;
     -:    58:
     -:    59:#if (EXCLUSIVE_ACCESS == 0)
     -:    60:  __disable_irq();
     -:    61:
     -:    62:  thread->thread_flags |= flags;
     -:    63:  thread_flags = thread->thread_flags;
     -:    64:
     -:    65:  if (primask == 0U) {
     -:    66:    __enable_irq();
     -:    67:  }
     -:    68:#else
 #####:    69:  thread_flags = atomic_set32(&thread->thread_flags, flags);
     -:    70:#endif
     -:    71:
     -:    72:  return thread_flags;
     -:    73:}
     -:    74:
     -:    75:/// Clear Thread Flags.
     -:    76:/// \param[in]  thread          thread object.
     -:    77:/// \param[in]  flags           specifies the flags to clear.
     -:    78:/// \return thread flags before clearing.
     -:    79:static uint32_t ThreadFlagsClear (os_thread_t *thread, uint32_t flags) {
     -:    80:#if (EXCLUSIVE_ACCESS == 0)
     -:    81:  uint32_t primask = __get_PRIMASK();
     -:    82:#endif
     -:    83:  uint32_t thread_flags;
     -:    84:
     -:    85:#if (EXCLUSIVE_ACCESS == 0)
     -:    86:  __disable_irq();
     -:    87:
     -:    88:  thread_flags = thread->thread_flags;
     -:    89:  thread->thread_flags &= ~flags;
     -:    90:
     -:    91:  if (primask == 0U) {
     -:    92:    __enable_irq();
     -:    93:  }
     -:    94:#else
     -:    95:  thread_flags = atomic_clr32(&thread->thread_flags, flags);
     -:    96:#endif
     -:    97:
     -:    98:  return thread_flags;
     -:    99:}
     -:   100:
     -:   101:/// Check Thread Flags.
     -:   102:/// \param[in]  thread          thread object.
     -:   103:/// \param[in]  flags           specifies the flags to check.
     -:   104:/// \param[in]  options         specifies flags options (osFlagsXxxx).
     -:   105:/// \return thread flags before clearing or 0 if specified flags have not been set.
     -:   106:static uint32_t ThreadFlagsCheck (os_thread_t *thread, uint32_t flags, uint32_t options) {
     -:   107:#if (EXCLUSIVE_ACCESS == 0)
     -:   108:  uint32_t primask;
     -:   109:#endif
     -:   110:  uint32_t thread_flags;
     -:   111:
 #####:   112:  if ((options & osFlagsNoClear) == 0U) {
     -:   113:#if (EXCLUSIVE_ACCESS == 0)
     -:   114:    primask = __get_PRIMASK();
     -:   115:    __disable_irq();
     -:   116:
     -:   117:    thread_flags = thread->thread_flags;
     -:   118:    if ((((options & osFlagsWaitAll) != 0U) && ((thread_flags & flags) != flags)) ||
     -:   119:        (((options & osFlagsWaitAll) == 0U) && ((thread_flags & flags) == 0U))) {
     -:   120:      thread_flags = 0U;
     -:   121:    } else {
     -:   122:      thread->thread_flags &= ~flags;
     -:   123:    }
     -:   124:
     -:   125:    if (primask == 0U) {
     -:   126:      __enable_irq();
     -:   127:    }
     -:   128:#else
 #####:   129:    if ((options & osFlagsWaitAll) != 0U) {
     -:   130:      thread_flags = atomic_chk32_all(&thread->thread_flags, flags);
     -:   131:    } else {
     -:   132:      thread_flags = atomic_chk32_any(&thread->thread_flags, flags);
     -:   133:    }
     -:   134:#endif
     -:   135:  } else {
 #####:   136:    thread_flags = thread->thread_flags;
 #####:   137:    if ((((options & osFlagsWaitAll) != 0U) && ((thread_flags & flags) != flags)) ||
     -:   138:        (((options & osFlagsWaitAll) == 0U) && ((thread_flags & flags) == 0U))) {
     -:   139:      thread_flags = 0U;
     -:   140:    }
     -:   141:  }
     -:   142:
     -:   143:  return thread_flags;
     -:   144:}
     -:   145:
     -:   146:/// Verify that Thread object pointer is valid.
     -:   147:/// \param[in]  thread          thread object.
     -:   148:/// \return true - valid, false - invalid.
     -:   149:static bool_t IsThreadPtrValid (const os_thread_t *thread) {
     -:   150:#ifdef RTX_OBJ_PTR_CHECK
     -:   151:  //lint --e{923} --e{9078} "cast from pointer to unsigned int" [MISRA Note 7]
     -:   152:  uint32_t cb_start  = (uint32_t)&__os_thread_cb_start__;
     -:   153:  uint32_t cb_length = (uint32_t)&__os_thread_cb_length__;
     -:   154:
     -:   155:  // Check the section boundaries
     -:   156:  if (((uint32_t)thread - cb_start) >= cb_length) {
     -:   157:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:   158:    return FALSE;
     -:   159:  }
     -:   160:  // Check the object alignment
     -:   161:  if ((((uint32_t)thread - cb_start) % sizeof(os_thread_t)) != 0U) {
     -:   162:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:   163:    return FALSE;
     -:   164:  }
     -:   165:#else
     -:   166:  // Check NULL pointer
     -:   167:  if (thread == NULL) {
     -:   168:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:   169:    return FALSE;
     -:   170:  }
     -:   171:#endif
     -:   172:  return TRUE;
     -:   173:}
     -:   174:
     -:   175:#if defined(RTX_EXECUTION_ZONE) && defined(RTX_SAFETY_CLASS)
     -:   176:/// Check if Thread Zone to Safety Class mapping is valid.
     -:   177:/// \param[in]  attr_bits       thread attributes.
     -:   178:/// \param[in]  thread          running thread.
     -:   179:/// \return true - valid, false - not valid.
     -:   180:static bool_t IsClassMappingValid (uint32_t attr_bits, const os_thread_t *thread) {
     -:   181:  uint32_t safety_class;
     -:   182:  uint32_t zone;
     -:   183:
     -:   184:  if ((attr_bits & osThreadZone_Valid) != 0U) {
     -:   185:    zone = (attr_bits & osThreadZone_Msk) >> osThreadZone_Pos;
     -:   186:  } else if (thread != NULL) {
     -:   187:    zone = thread->zone;
     -:   188:  } else {
     -:   189:    zone = 0U;
     -:   190:  }
     -:   191:
     -:   192:  if ((attr_bits & osSafetyClass_Valid) != 0U) {
     -:   193:    safety_class = (attr_bits & osSafetyClass_Msk) >> osSafetyClass_Pos;
     -:   194:  } else if (thread != NULL) {
     -:   195:    safety_class = (uint32_t)thread->attr >> osRtxAttrClass_Pos;
     -:   196:  } else {
     -:   197:    safety_class = 0U;
     -:   198:  }
     -:   199:
     -:   200:  // Check if zone is free or assigned to class
     -:   201:  if ((ThreadClassTable[zone] == 0U) ||
     -:   202:      (ThreadClassTable[zone] == (0x80U | safety_class))) {
     -:   203:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:   204:    return TRUE;
     -:   205:  }
     -:   206:  // Invalid class to zone mapping
     -:   207:  return FALSE;
     -:   208:}
     -:   209:#endif
     -:   210:
     -:   211:
     -:   212://  ==== Library functions ====
     -:   213:
     -:   214:/// Put a Thread into specified Object list sorted by Priority (Highest at Head).
     -:   215:/// \param[in]  object          generic object.
     -:   216:/// \param[in]  thread          thread object.
     -:   217:void osRtxThreadListPut (os_object_t *object, os_thread_t *thread) {
     -:   218:  os_thread_t *prev, *next;
     -:   219:  int32_t      priority;
     -:   220:
 #####:   221:  priority = thread->priority;
     -:   222:
     -:   223:  prev = osRtxThreadObject(object);
     -:   224:  next = prev->thread_next;
 #####:   225:  while ((next != NULL) && (next->priority >= priority)) {
     -:   226:    prev = next;
     -:   227:    next = next->thread_next;
     -:   228:  }
     -:   229:  thread->thread_prev = prev;
 #####:   230:  thread->thread_next = next;
 #####:   231:  prev->thread_next = thread;
     -:   232:  if (next != NULL) {
 #####:   233:    next->thread_prev = thread;
 #####:   234:  }
 #####:   235:}
     -:   236:
     -:   237:/// Get a Thread with Highest Priority from specified Object list and remove it.
     -:   238:/// \param[in]  object          generic object.
     -:   239:/// \return thread object.
     1:   240:os_thread_t *osRtxThreadListGet (os_object_t *object) {
     -:   241:  os_thread_t *thread;
     -:   242:
 #####:   243:  thread = object->thread_list;
 #####:   244:  object->thread_list = thread->thread_next;
 #####:   245:  if (thread->thread_next != NULL) {
 #####:   246:    thread->thread_next->thread_prev = osRtxThreadObject(object);
     -:   247:  }
 #####:   248:  thread->thread_prev = NULL;
     -:   249:
     1:   250:  return thread;
     -:   251:}
     -:   252:
     -:   253:/// Retrieve Thread list root object.
     -:   254:/// \param[in]  thread          thread object.
     -:   255:/// \return root object.
     -:   256:static void *osRtxThreadListRoot (os_thread_t *thread) {
     -:   257:  os_thread_t *thread0;
     -:   258:
     -:   259:  thread0 = thread;
 #####:   260:  while (thread0->id == osRtxIdThread) {
 #####:   261:    thread0 = thread0->thread_prev;
     -:   262:  }
     -:   263:  return thread0;
     -:   264:}
     -:   265:
     -:   266:/// Re-sort a Thread in linked Object list by Priority (Highest at Head).
     -:   267:/// \param[in]  thread          thread object.
     -:   268:void osRtxThreadListSort (os_thread_t *thread) {
     -:   269:  os_object_t *object;
     -:   270:  os_thread_t *thread0;
     -:   271:
     -:   272:  // Search for object
     -:   273:  thread0 = thread;
 #####:   274:  while ((thread0 != NULL) && (thread0->id == osRtxIdThread)) {
 #####:   275:    thread0 = thread0->thread_prev;
     -:   276:  }
     -:   277:  object = osRtxObject(thread0);
     -:   278:
 #####:   279:  if (object != NULL) {
     -:   280:    osRtxThreadListRemove(thread);
     -:   281:    osRtxThreadListPut(object, thread);
     -:   282:  }
 #####:   283:}
     -:   284:
     -:   285:/// Remove a Thread from linked Object list.
     -:   286:/// \param[in]  thread          thread object.
     -:   287:void osRtxThreadListRemove (os_thread_t *thread) {
     -:   288:
 #####:   289:  if (thread->thread_prev != NULL) {
 #####:   290:    thread->thread_prev->thread_next = thread->thread_next;
 #####:   291:    if (thread->thread_next != NULL) {
 #####:   292:      thread->thread_next->thread_prev = thread->thread_prev;
     -:   293:    }
 #####:   294:    thread->thread_prev = NULL;
     -:   295:  }
 #####:   296:}
     -:   297:
     -:   298:/// Unlink a Thread from specified linked list.
     -:   299:/// \param[in]  thread          thread object.
     -:   300:static void osRtxThreadListUnlink (os_thread_t **thread_list, os_thread_t *thread) {
     -:   301:
 #####:   302:  if (thread->thread_next != NULL) {
     -:   303:    thread->thread_next->thread_prev = thread->thread_prev;
     -:   304:  }
     -:   305:  if (thread->thread_prev != NULL) {
 #####:   306:    thread->thread_prev->thread_next = thread->thread_next;
 #####:   307:    thread->thread_prev = NULL;
 #####:   308:  } else {
 #####:   309:    *thread_list = thread->thread_next;
     -:   310:  }
     -:   311:}
     -:   312:
     -:   313:/// Mark a Thread as Ready and put it into Ready list (sorted by Priority).
     -:   314:/// \param[in]  thread          thread object.
 #####:   315:void osRtxThreadReadyPut (os_thread_t *thread) {
     -:   316:
 #####:   317:  thread->state = osRtxThreadReady;
     -:   318:  osRtxThreadListPut(&osRtxInfo.thread.ready, thread);
 #####:   319:}
     -:   320:
     -:   321:/// Insert a Thread into the Delay list sorted by Delay (Lowest at Head).
     -:   322:/// \param[in]  thread          thread object.
     -:   323:/// \param[in]  delay           delay value.
     -:   324:static void osRtxThreadDelayInsert (os_thread_t *thread, uint32_t delay) {
     -:   325:  os_thread_t *prev, *next;
     -:   326:
     1:   327:  if (delay == osWaitForever) {
     -:   328:    prev = NULL;
     -:   329:    next = osRtxInfo.thread.wait_list;
 #####:   330:    while (next != NULL)  {
     -:   331:      prev = next;
 #####:   332:      next = next->delay_next;
     -:   333:    }
 #####:   334:    thread->delay = delay;
     -:   335:    thread->delay_prev = prev;
 #####:   336:    thread->delay_next = NULL;
 #####:   337:    if (prev != NULL) {
 #####:   338:      prev->delay_next = thread;
     -:   339:    } else {
 #####:   340:      osRtxInfo.thread.wait_list = thread;
     -:   341:    }
     -:   342:  } else {
     -:   343:    prev = NULL;
     -:   344:    next = osRtxInfo.thread.delay_list;
 #####:   345:    while ((next != NULL) && (next->delay <= delay)) {
 #####:   346:      delay -= next->delay;
     -:   347:      prev = next;
     -:   348:      next = next->delay_next;
     -:   349:    }
 #####:   350:    thread->delay = delay;
     -:   351:    thread->delay_prev = prev;
 #####:   352:    thread->delay_next = next;
 #####:   353:    if (prev != NULL) {
     -:   354:      prev->delay_next = thread;
     -:   355:    } else {
     -:   356:      osRtxInfo.thread.delay_list = thread;
     -:   357:    }
 #####:   358:    if (next != NULL) {
 #####:   359:      next->delay -= delay;
 #####:   360:      next->delay_prev = thread;
     -:   361:    }
     -:   362:  }
     -:   363:}
     -:   364:
     -:   365:/// Remove a Thread from the Delay list.
     -:   366:/// \param[in]  thread          thread object.
     -:   367:void osRtxThreadDelayRemove (os_thread_t *thread) {
     -:   368:
 #####:   369:  if (thread->delay == osWaitForever) {
 #####:   370:    if (thread->delay_next != NULL) {
 #####:   371:      thread->delay_next->delay_prev = thread->delay_prev;
     -:   372:    }
 #####:   373:    if (thread->delay_prev != NULL) {
     -:   374:      thread->delay_prev->delay_next = thread->delay_next;
     -:   375:      thread->delay_prev = NULL;
     -:   376:    } else {
 #####:   377:      osRtxInfo.thread.wait_list = thread->delay_next;
     -:   378:    }
     -:   379:  } else {
 #####:   380:    if (thread->delay_next != NULL) {
 #####:   381:      thread->delay_next->delay += thread->delay;
 #####:   382:      thread->delay_next->delay_prev = thread->delay_prev;
     -:   383:    }
 #####:   384:    if (thread->delay_prev != NULL) {
     -:   385:      thread->delay_prev->delay_next = thread->delay_next;
     -:   386:      thread->delay_prev = NULL;
     -:   387:    } else {
 #####:   388:      osRtxInfo.thread.delay_list = thread->delay_next;
     -:   389:    }
     -:   390:  }
 #####:   391:  thread->delay = 0U;
 #####:   392:}
     -:   393:
     -:   394:/// Process Thread Delay Tick (executed each System Tick).
  3888:   395:void osRtxThreadDelayTick (void) {
     -:   396:  os_thread_t *thread;
     -:   397:  os_object_t *object;
     -:   398:
  3888:   399:  thread = osRtxInfo.thread.delay_list;
  3888:   400:  if (thread == NULL) {
     -:   401:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:   402:    return;
     -:   403:  }
     -:   404:
 #####:   405:  thread->delay--;
     -:   406:
 #####:   407:  if (thread->delay == 0U) {
     -:   408:    do {
 #####:   409:      switch (thread->state) {
     -:   410:        case osRtxThreadWaitingDelay:
 #####:   411:          EvrRtxDelayCompleted(thread);
     -:   412:          break;
     -:   413:        case osRtxThreadWaitingThreadFlags:
 #####:   414:          EvrRtxThreadFlagsWaitTimeout(thread);
     -:   415:          break;
     -:   416:        case osRtxThreadWaitingEventFlags:
 #####:   417:          EvrRtxEventFlagsWaitTimeout((osEventFlagsId_t)osRtxThreadListRoot(thread));
     -:   418:          break;
     -:   419:        case osRtxThreadWaitingMutex:
     -:   420:          object = osRtxObject(osRtxThreadListRoot(thread));
 #####:   421:          osRtxMutexOwnerRestore(osRtxMutexObject(object), thread);
 #####:   422:          EvrRtxMutexAcquireTimeout(osRtxMutexObject(object));
     -:   423:          break;
     -:   424:        case osRtxThreadWaitingSemaphore:
 #####:   425:          EvrRtxSemaphoreAcquireTimeout((osSemaphoreId_t)osRtxThreadListRoot(thread));
     -:   426:          break;
     -:   427:        case osRtxThreadWaitingMemoryPool:
 #####:   428:          EvrRtxMemoryPoolAllocTimeout((osMemoryPoolId_t)osRtxThreadListRoot(thread));
     -:   429:          break;
     -:   430:        case osRtxThreadWaitingMessageGet:
 #####:   431:          EvrRtxMessageQueueGetTimeout((osMessageQueueId_t)osRtxThreadListRoot(thread));
     -:   432:          break;
     -:   433:        case osRtxThreadWaitingMessagePut:
 #####:   434:          EvrRtxMessageQueuePutTimeout((osMessageQueueId_t)osRtxThreadListRoot(thread));
     -:   435:          break;
     -:   436:        default:
     -:   437:          // Invalid
     -:   438:          break;
     -:   439:      }
 #####:   440:      EvrRtxThreadUnblocked(thread, (osRtxThreadRegPtr(thread))[0]);
     -:   441:      osRtxThreadListRemove(thread);
     -:   442:      osRtxThreadReadyPut(thread);
 #####:   443:      thread = thread->delay_next;
 #####:   444:    } while ((thread != NULL) && (thread->delay == 0U));
     -:   445:    if (thread != NULL) {
 #####:   446:      thread->delay_prev = NULL;
     -:   447:    }
 #####:   448:    osRtxInfo.thread.delay_list = thread;
     -:   449:  }
  3888:   450:}
     -:   451:
     -:   452:/// Get pointer to Thread registers (R0..R3)
     -:   453:/// \param[in]  thread          thread object.
     -:   454:/// \return pointer to registers R0-R3.
     -:   455:uint32_t *osRtxThreadRegPtr (const os_thread_t *thread) {
 #####:   456:  uint32_t addr = thread->sp + StackOffsetR0(thread->stack_frame);
     -:   457:  //lint -e{923} -e{9078} "cast from unsigned int to pointer"
 #####:   458:  return ((uint32_t *)addr);
     -:   459:}
     -:   460:
     -:   461:/// Block running Thread execution and register it as Ready to Run.
     -:   462:/// \param[in]  thread          running thread object.
     -:   463:static void osRtxThreadBlock (os_thread_t *thread) {
     -:   464:  os_thread_t *prev, *next;
     -:   465:  int32_t      priority;
     -:   466:
 #####:   467:  thread->state = osRtxThreadReady;
     -:   468:
     -:   469:  priority = thread->priority;
     -:   470:
     -:   471:  prev = osRtxThreadObject(&osRtxInfo.thread.ready);
     -:   472:  next = prev->thread_next;
     -:   473:
 #####:   474:  while ((next != NULL) && (next->priority > priority)) {
     -:   475:    prev = next;
     -:   476:    next = next->thread_next;
     -:   477:  }
     -:   478:  thread->thread_prev = prev;
 #####:   479:  thread->thread_next = next;
 #####:   480:  prev->thread_next = thread;
     -:   481:  if (next != NULL) {
 #####:   482:    next->thread_prev = thread;
 #####:   483:  }
     -:   484:
 #####:   485:  EvrRtxThreadPreempted(thread);
     -:   486:}
     -:   487:
     -:   488:/// Switch to specified Thread.
     -:   489:/// \param[in]  thread          thread object.
     -:   490:void osRtxThreadSwitch (os_thread_t *thread) {
     -:   491:
 #####:   492:  thread->state = osRtxThreadRunning;
 #####:   493:  SetPrivileged((bool_t)((thread->attr & osThreadPrivileged) != 0U));
 #####:   494:  osRtxInfo.thread.run.next = thread;
 #####:   495:  EvrRtxThreadSwitched(thread);
     -:   496:}
     -:   497:
     -:   498:/// Dispatch specified Thread or Ready Thread with Highest Priority.
     -:   499:/// \param[in]  thread          thread object or NULL.
  4334:   500:void osRtxThreadDispatch (os_thread_t *thread) {
     -:   501:  uint8_t      kernel_state;
     -:   502:  os_thread_t *thread_running;
     -:   503:  os_thread_t *thread_ready;
     -:   504:
     -:   505:  kernel_state   = osRtxKernelGetState();
     -:   506:  thread_running = osRtxThreadGetRunning();
     -:   507:
  4334:   508:  if (thread == NULL) {
     -:   509:    thread_ready = osRtxInfo.thread.ready.thread_list;
  4331:   510:    if ((kernel_state == osRtxKernelRunning) &&
     -:   511:        (thread_ready != NULL) &&
   448:   512:        (thread_ready->priority > thread_running->priority)) {
     -:   513:      // Preempt running Thread
     -:   514:      osRtxThreadListRemove(thread_ready);
     -:   515:      osRtxThreadBlock(thread_running);
     -:   516:      osRtxThreadSwitch(thread_ready);
     -:   517:    }
     -:   518:  } else {
     3:   519:    if ((kernel_state == osRtxKernelRunning) &&
 #####:   520:        (thread->priority > thread_running->priority)) {
     -:   521:      // Preempt running Thread
     -:   522:      osRtxThreadBlock(thread_running);
     -:   523:      osRtxThreadSwitch(thread);
     -:   524:    } else {
     -:   525:      // Put Thread into Ready list
     -:   526:      osRtxThreadReadyPut(thread);
     -:   527:    }
     -:   528:  }
     1:   529:}
     -:   530:
     -:   531:/// Exit Thread wait state.
     -:   532:/// \param[in]  thread          thread object.
     -:   533:/// \param[in]  ret_val         return value.
     -:   534:/// \param[in]  dispatch        dispatch flag.
 #####:   535:void osRtxThreadWaitExit (os_thread_t *thread, uint32_t ret_val, bool_t dispatch) {
     -:   536:  uint32_t *reg;
     -:   537:
 #####:   538:  EvrRtxThreadUnblocked(thread, ret_val);
     -:   539:
     -:   540:  reg = osRtxThreadRegPtr(thread);
 #####:   541:  reg[0] = ret_val;
     -:   542:
     -:   543:  osRtxThreadDelayRemove(thread);
 #####:   544:  if (dispatch) {
 #####:   545:    osRtxThreadDispatch(thread);
     -:   546:  } else {
     -:   547:    osRtxThreadReadyPut(thread);
     -:   548:  }
 #####:   549:}
     -:   550:
     -:   551:/// Enter Thread wait state.
     -:   552:/// \param[in]  state           new thread state.
     -:   553:/// \param[in]  timeout         timeout.
     -:   554:/// \return true - success, false - failure.
     1:   555:bool_t osRtxThreadWaitEnter (uint8_t state, uint32_t timeout) {
     -:   556:  os_thread_t *thread;
     -:   557:
     -:   558:  // Check if Kernel is running
     1:   559:  if (osRtxKernelGetState() != osRtxKernelRunning) {
     -:   560:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:   561:    return FALSE;
     -:   562:  }
     -:   563:
     -:   564:  // Check if any thread is ready
     -:   565:  if (osRtxInfo.thread.ready.thread_list == NULL) {
     -:   566:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:   567:    return FALSE;
     -:   568:  }
     -:   569:
     -:   570:  // Get running thread
     -:   571:  thread = osRtxThreadGetRunning();
     -:   572:
 #####:   573:  EvrRtxThreadBlocked(thread, timeout);
     -:   574:
     1:   575:  thread->state = state;
     -:   576:  osRtxThreadDelayInsert(thread, timeout);
     -:   577:  thread = osRtxThreadListGet(&osRtxInfo.thread.ready);
     -:   578:  osRtxThreadSwitch(thread);
     -:   579:
     -:   580:  return TRUE;
     1:   581:}
     -:   582:
     -:   583:#ifdef RTX_STACK_CHECK
     -:   584:/// Check current running Thread Stack.
     -:   585:/// \param[in]  thread          running thread.
     -:   586:/// \return true - success, false - failure.
     -:   587://lint -esym(714,osRtxThreadStackCheck) "Referenced by Exception handlers"
     -:   588://lint -esym(759,osRtxThreadStackCheck) "Prototype in header"
     -:   589://lint -esym(765,osRtxThreadStackCheck) "Global scope"
     -:   590:bool_t osRtxThreadStackCheck (const os_thread_t *thread) {
     -:   591:
     -:   592:  //lint -e{923} "cast from pointer to unsigned int"
     -:   593:  //lint -e{9079} -e{9087} "cast between pointers to different object types"
 #####:   594:  if ((thread->sp <= (uint32_t)thread->stack_mem) ||
     1:   595:      (*((uint32_t *)thread->stack_mem) != osRtxStackMagicWord)) {
     -:   596:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:   597:    return FALSE;
     -:   598:  }
     -:   599:  return TRUE;
     1:   600:}
     -:   601:#endif
     -:   602:
     -:   603:#ifdef RTX_THREAD_WATCHDOG
     -:   604:
     -:   605:/// Insert a Thread into the Watchdog list, sorted by tick (lowest at Head).
     -:   606:/// \param[in]  thread          thread object.
     -:   607:/// \param[in]  ticks           watchdog timeout.
     -:   608:static void osRtxThreadWatchdogInsert (os_thread_t *thread, uint32_t ticks) {
     -:   609:  os_thread_t *prev, *next;
     -:   610:
     -:   611:  if (ticks == 0U) {
     -:   612:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:   613:    return;
     -:   614:  }
     -:   615:  prev = NULL;
     -:   616:  next = osRtxInfo.thread.wdog_list;
     -:   617:  while ((next != NULL) && ((next->wdog_tick <= ticks))) {
     -:   618:    ticks -= next->wdog_tick;
     -:   619:    prev   = next;
     -:   620:    next   = next->wdog_next;
     -:   621:  }
     -:   622:  thread->wdog_tick = ticks;
     -:   623:  thread->wdog_next = next;
     -:   624:  if (next != NULL) {
     -:   625:    next->wdog_tick -= ticks;
     -:   626:  }
     -:   627:  if (prev != NULL) {
     -:   628:    prev->wdog_next = thread;
     -:   629:  } else {
     -:   630:    osRtxInfo.thread.wdog_list = thread;
     -:   631:  }
     -:   632:}
     -:   633:
     -:   634:/// Remove a Thread from the Watchdog list.
     -:   635:/// \param[in]  thread          thread object.
     -:   636:void osRtxThreadWatchdogRemove (const os_thread_t *thread) {
     -:   637:  os_thread_t *prev, *next;
     -:   638:
     -:   639:  prev = NULL;
     -:   640:  next = osRtxInfo.thread.wdog_list;
     -:   641:  while ((next != NULL) && (next != thread)) {
     -:   642:    prev = next;
     -:   643:    next = next->wdog_next;
     -:   644:  }
     -:   645:  if (next == NULL) {
     -:   646:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:   647:    return;
     -:   648:  }
     -:   649:  if (thread->wdog_next != NULL) {
     -:   650:    thread->wdog_next->wdog_tick += thread->wdog_tick;
     -:   651:  }
     -:   652:  if (prev != NULL) {
     -:   653:    prev->wdog_next = thread->wdog_next;
     -:   654:  } else {
     -:   655:    osRtxInfo.thread.wdog_list = thread->wdog_next;
     -:   656:  }
     -:   657:}
     -:   658:
     -:   659:/// Process Watchdog Tick (executed each System Tick).
     -:   660:void osRtxThreadWatchdogTick (void) {
     -:   661:  os_thread_t *thread_running;
     -:   662:  os_thread_t *thread;
     -:   663:#ifdef RTX_SAFETY_CLASS
     -:   664:  os_thread_t *next;
     -:   665:#endif
     -:   666:  uint32_t ticks;
     -:   667:
     -:   668:  thread = osRtxInfo.thread.wdog_list;
     -:   669:  if (thread == NULL) {
     -:   670:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:   671:    return;
     -:   672:  }
     -:   673:  thread->wdog_tick--;
     -:   674:
     -:   675:  if (thread->wdog_tick == 0U) {
     -:   676:    // Call watchdog handler for all expired threads
     -:   677:    thread_running = osRtxThreadGetRunning();
     -:   678:    do {
     -:   679:      osRtxThreadSetRunning(osRtxInfo.thread.run.next);
     -:   680:#ifdef RTX_SAFETY_CLASS
     -:   681:      // First the highest safety thread (sorted by Safety Class)
     -:   682:      next = thread->wdog_next;
     -:   683:      while ((next != NULL) && (next->wdog_tick == 0U)) {
     -:   684:        if ((next->attr & osRtxAttrClass_Msk) > (thread->attr & osRtxAttrClass_Msk)) {
     -:   685:          thread = next;
     -:   686:        }
     -:   687:        next = next->wdog_next;
     -:   688:      }
     -:   689:#endif
     -:   690:      osRtxThreadWatchdogRemove(thread);
     -:   691:      EvrRtxThreadWatchdogExpired(thread);
     -:   692:#ifdef RTX_EXECUTION_ZONE
     -:   693:      WatchdogAlarmFlag = 1U;
     -:   694:#endif
     -:   695:      ticks = osWatchdogAlarm_Handler(thread);
     -:   696:#ifdef RTX_EXECUTION_ZONE
     -:   697:      WatchdogAlarmFlag = 0U;
     -:   698:#endif
     -:   699:      osRtxThreadWatchdogInsert(thread, ticks);
     -:   700:      thread = osRtxInfo.thread.wdog_list;
     -:   701:    } while ((thread != NULL) && (thread->wdog_tick == 0U));
     -:   702:    osRtxThreadSetRunning(thread_running);
     -:   703:  }
     -:   704:}
     -:   705:
     -:   706:#endif
     -:   707:
     -:   708:static __NO_RETURN void osThreadEntry (void *argument, osThreadFunc_t func) {
     3:   709:  func(argument);
 #####:   710:  osThreadExit();
     -:   711:}
     -:   712:
     -:   713:
     -:   714://  ==== Post ISR processing ====
     -:   715:
     -:   716:/// Thread post ISR processing.
     -:   717:/// \param[in]  thread          thread object.
 #####:   718:static void osRtxThreadPostProcess (os_thread_t *thread) {
     -:   719:  uint32_t thread_flags;
     -:   720:
     -:   721:  // Check if Thread is waiting for Thread Flags
 #####:   722:  if (thread->state == osRtxThreadWaitingThreadFlags) {
 #####:   723:    thread_flags = ThreadFlagsCheck(thread, thread->wait_flags, thread->flags_options);
 #####:   724:    if (thread_flags != 0U) {
 #####:   725:      osRtxThreadWaitExit(thread, thread_flags, FALSE);
 #####:   726:      EvrRtxThreadFlagsWaitCompleted(thread->wait_flags, thread->flags_options, thread_flags, thread);
     -:   727:    }
     -:   728:  }
 #####:   729:}
     -:   730:
     -:   731:
     -:   732://  ==== Service Calls ====
     -:   733:
     -:   734:/// Create a thread and add it to Active Threads.
     -:   735:/// \note API identical to osThreadNew
     3:   736:static osThreadId_t svcRtxThreadNew (osThreadFunc_t func, void *argument, const osThreadAttr_t *attr) {
     -:   737:  os_thread_t       *thread;
     -:   738:#if defined(RTX_SAFETY_CLASS) || defined(RTX_EXECUTION_ZONE)
     -:   739:  const os_thread_t *thread_running = osRtxThreadGetRunning();
     -:   740:#endif
     -:   741:  uint32_t           attr_bits;
     -:   742:  void              *stack_mem;
     -:   743:  uint32_t           stack_size;
     -:   744:  osPriority_t       priority;
     -:   745:  uint8_t            flags;
     -:   746:  const char        *name;
     -:   747:  uint32_t          *ptr;
     -:   748:  uint32_t           n;
     -:   749:#ifdef RTX_TZ_CONTEXT
     -:   750:  TZ_ModuleId_t      tz_module;
     -:   751:  TZ_MemoryId_t      tz_memory;
     -:   752:#endif
     -:   753:
     -:   754:  // Check parameters
     3:   755:  if (func == NULL) {
     -:   756:    EvrRtxThreadError(NULL, (int32_t)osErrorParameter);
     -:   757:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:   758:    return NULL;
     -:   759:  }
     -:   760:
     -:   761:  // Process attributes
     3:   762:  if (attr != NULL) {
     -:   763:    name       = attr->name;
     2:   764:    attr_bits  = attr->attr_bits;
     -:   765:    //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 6]
     -:   766:    thread     = attr->cb_mem;
     -:   767:    //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 6]
     -:   768:    stack_mem  = attr->stack_mem;
     -:   769:    stack_size = attr->stack_size;
     -:   770:    priority   = attr->priority;
     -:   771:#ifdef RTX_TZ_CONTEXT
     -:   772:    tz_module  = attr->tz_module;
     -:   773:#endif
     2:   774:    if (((attr_bits & osThreadPrivileged) != 0U) && ((attr_bits & osThreadUnprivileged) != 0U)) {
     -:   775:      EvrRtxThreadError(NULL, (int32_t)osErrorParameter);
     -:   776:      //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:   777:      return NULL;
     -:   778:    }
     2:   779:    if ((attr_bits & osSafetyClass_Valid) != 0U) {
     -:   780:#ifdef RTX_SAFETY_CLASS
     -:   781:      if ((thread_running != NULL) &&
     -:   782:          ((thread_running->attr >> osRtxAttrClass_Pos) <
     -:   783:          (uint8_t)((attr_bits & osSafetyClass_Msk) >> osSafetyClass_Pos))) {
     -:   784:        EvrRtxThreadError(NULL, (int32_t)osErrorSafetyClass);
     -:   785:        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:   786:        return NULL;
     -:   787:      }
     -:   788:#else
 #####:   789:      EvrRtxThreadError(NULL, (int32_t)osErrorSafetyClass);
     -:   790:      //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:   791:      return NULL;
     -:   792:#endif
     -:   793:    }
     2:   794:    if (thread != NULL) {
     2:   795:      if (!IsThreadPtrValid(thread) || (attr->cb_size != sizeof(os_thread_t))) {
     -:   796:        EvrRtxThreadError(NULL, osRtxErrorInvalidControlBlock);
     -:   797:        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:   798:        return NULL;
     -:   799:      }
     -:   800:    } else {
     2:   801:      if (attr->cb_size != 0U) {
     -:   802:        EvrRtxThreadError(NULL, osRtxErrorInvalidControlBlock);
     -:   803:        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:   804:        return NULL;
     -:   805:      }
     -:   806:    }
     2:   807:    if (stack_mem != NULL) {
     -:   808:      //lint -e{923} "cast from pointer to unsigned int" [MISRA Note 7]
     2:   809:      if ((((uint32_t)stack_mem & 7U) != 0U) || (stack_size == 0U)) {
     -:   810:        EvrRtxThreadError(NULL, osRtxErrorInvalidThreadStack);
     -:   811:        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:   812:        return NULL;
     -:   813:      }
     -:   814:    }
     2:   815:    if (priority == osPriorityNone) {
     -:   816:      priority = osPriorityNormal;
     -:   817:    } else {
     2:   818:      if ((priority < osPriorityIdle) || (priority > osPriorityISR)) {
 #####:   819:        EvrRtxThreadError(NULL, osRtxErrorInvalidPriority);
     -:   820:        //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:   821:        return NULL;
     -:   822:      }
     -:   823:    }
     -:   824:  } else {
     -:   825:    name       = NULL;
     -:   826:    attr_bits  = 0U;
     -:   827:    thread     = NULL;
     -:   828:    stack_mem  = NULL;
     -:   829:    stack_size = 0U;
     -:   830:    priority   = osPriorityNormal;
     -:   831:#ifdef RTX_TZ_CONTEXT
     -:   832:    tz_module  = 0U;
     -:   833:#endif
     -:   834:  }
     -:   835:
     -:   836:  // Set default privilege if not specified
     3:   837:  if ((attr_bits & (osThreadPrivileged | osThreadUnprivileged)) == 0U) {
     3:   838:    if ((osRtxConfig.flags & osRtxConfigPrivilegedMode) != 0U) {
     3:   839:      attr_bits |= osThreadPrivileged;
     -:   840:    } else {
     3:   841:      attr_bits |= osThreadUnprivileged;
     -:   842:    }
     -:   843:  }
     -:   844:
     -:   845:#ifdef RTX_SAFETY_FEATURES
     -:   846:  // Check privilege protection
     -:   847:  if ((attr_bits & osThreadPrivileged) != 0U) {
     -:   848:    if ((osRtxInfo.kernel.protect & osRtxKernelProtectPrivileged) != 0U) {
     -:   849:      EvrRtxThreadError(NULL, osRtxErrorInvalidPrivilegedMode);
     -:   850:      //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:   851:      return NULL;
     -:   852:    }
     -:   853:  }
     -:   854:#endif
     -:   855:
     -:   856:#if defined(RTX_EXECUTION_ZONE) && defined(RTX_SAFETY_CLASS)
     -:   857:  // Check class to zone mapping
     -:   858:  if (!IsClassMappingValid(attr_bits, thread_running)) {
     -:   859:    EvrRtxThreadError(NULL, (int32_t)osErrorSafetyClass);
     -:   860:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:   861:    return NULL;
     -:   862:  }
     -:   863:#endif
     -:   864:
     -:   865:  // Check stack size
     -:   866:  if (stack_size != 0U) {
     2:   867:    if (((stack_size & 7U) != 0U) || (stack_size < (64U + 8U)) || (stack_size > 0x7FFFFFFFU)) {
     -:   868:      EvrRtxThreadError(NULL, osRtxErrorInvalidThreadStack);
     -:   869:      //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:   870:      return NULL;
     -:   871:    }
     -:   872:  }
     -:   873:
     -:   874:  // Allocate object memory if not provided
     3:   875:  if (thread == NULL) {
     1:   876:    if (osRtxInfo.mpi.thread != NULL) {
     -:   877:      //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
 #####:   878:      thread = osRtxMemoryPoolAlloc(osRtxInfo.mpi.thread);
     -:   879:#ifndef RTX_OBJ_PTR_CHECK
     -:   880:    } else {
     -:   881:      //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
     1:   882:      thread = osRtxMemoryAlloc(osRtxInfo.mem.common, sizeof(os_thread_t), 1U);
     -:   883:#endif
     -:   884:    }
     -:   885:#ifdef RTX_OBJ_MEM_USAGE
     -:   886:    if (thread != NULL) {
     -:   887:      uint32_t used;
     -:   888:      osRtxThreadMemUsage.cnt_alloc++;
     -:   889:      used = osRtxThreadMemUsage.cnt_alloc - osRtxThreadMemUsage.cnt_free;
     -:   890:      if (osRtxThreadMemUsage.max_used < used) {
     -:   891:        osRtxThreadMemUsage.max_used = used;
     -:   892:      }
     -:   893:    }
     -:   894:#endif
     -:   895:    flags = osRtxFlagSystemObject;
     -:   896:  } else {
     -:   897:    flags = 0U;
     -:   898:  }
     -:   899:
     -:   900:  // Allocate stack memory if not provided
     2:   901:  if ((thread != NULL) && (stack_mem == NULL)) {
     1:   902:    if (stack_size == 0U) {
     1:   903:      stack_size = osRtxConfig.thread_stack_size;
     1:   904:      if (osRtxInfo.mpi.stack != NULL) {
     -:   905:        //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
 #####:   906:        stack_mem = osRtxMemoryPoolAlloc(osRtxInfo.mpi.stack);
 #####:   907:        if (stack_mem != NULL) {
     -:   908:          flags |= osRtxThreadFlagDefStack;
     -:   909:        }
     -:   910:      } else {
     -:   911:        //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
     1:   912:        stack_mem = osRtxMemoryAlloc(osRtxInfo.mem.stack, stack_size, 0U);
     -:   913:      }
     -:   914:    } else {
     -:   915:      //lint -e{9079} "conversion from pointer to void to pointer to other type" [MISRA Note 5]
 #####:   916:      stack_mem = osRtxMemoryAlloc(osRtxInfo.mem.stack, stack_size, 0U);
     -:   917:    }
     1:   918:    if (stack_mem == NULL) {
 #####:   919:      if ((flags & osRtxFlagSystemObject) != 0U) {
     -:   920:#ifdef RTX_OBJ_PTR_CHECK
     -:   921:        (void)osRtxMemoryPoolFree(osRtxInfo.mpi.thread, thread);
     -:   922:#else
 #####:   923:        if (osRtxInfo.mpi.thread != NULL) {
 #####:   924:          (void)osRtxMemoryPoolFree(osRtxInfo.mpi.thread, thread);
     -:   925:        } else {
 #####:   926:          (void)osRtxMemoryFree(osRtxInfo.mem.common, thread);
     -:   927:        }
     -:   928:#endif
     -:   929:#ifdef RTX_OBJ_MEM_USAGE
     -:   930:        osRtxThreadMemUsage.cnt_free++;
     -:   931:#endif
     -:   932:      }
     -:   933:      thread = NULL;
     -:   934:    }
     1:   935:    flags |= osRtxFlagSystemMemory;
     -:   936:  }
     -:   937:
     -:   938:#ifdef RTX_TZ_CONTEXT
     -:   939:  // Allocate secure process stack
     -:   940:  if ((thread != NULL) && (tz_module != 0U)) {
     -:   941:    tz_memory = TZ_AllocModuleContext_S(tz_module);
     -:   942:    if (tz_memory == 0U) {
     -:   943:      EvrRtxThreadError(NULL, osRtxErrorTZ_AllocContext_S);
     -:   944:      if ((flags & osRtxFlagSystemMemory) != 0U) {
     -:   945:        if ((flags & osRtxThreadFlagDefStack) != 0U) {
     -:   946:          (void)osRtxMemoryPoolFree(osRtxInfo.mpi.stack, thread->stack_mem);
     -:   947:        } else {
     -:   948:          (void)osRtxMemoryFree(osRtxInfo.mem.stack, thread->stack_mem);
     -:   949:        }
     -:   950:      }
     -:   951:      if ((flags & osRtxFlagSystemObject) != 0U) {
     -:   952:#ifdef RTX_OBJ_PTR_CHECK
     -:   953:        (void)osRtxMemoryPoolFree(osRtxInfo.mpi.thread, thread);
     -:   954:#else
     -:   955:        if (osRtxInfo.mpi.thread != NULL) {
     -:   956:          (void)osRtxMemoryPoolFree(osRtxInfo.mpi.thread, thread);
     -:   957:        } else {
     -:   958:          (void)osRtxMemoryFree(osRtxInfo.mem.common, thread);
     -:   959:        }
     -:   960:#endif
     -:   961:#ifdef RTX_OBJ_MEM_USAGE
     -:   962:        osRtxThreadMemUsage.cnt_free++;
     -:   963:#endif
     -:   964:      }
     -:   965:      thread = NULL;
     -:   966:    }
     -:   967:  } else {
     -:   968:    tz_memory = 0U;
     -:   969:  }
     -:   970:#endif
     -:   971:
     3:   972:  if (thread != NULL) {
     -:   973:    // Initialize control block
     -:   974:    //lint --e{923}  --e{9078} "cast between pointers and unsigned int"
     -:   975:    //lint --e{9079} --e{9087} "cast between pointers to different object types"
     -:   976:    //lint --e{9074} "conversion between a pointer to function and another type"
     3:   977:    thread->id            = osRtxIdThread;
     -:   978:    thread->state         = osRtxThreadReady;
     3:   979:    thread->flags         = flags;
     3:   980:    thread->attr          = (uint8_t)(attr_bits & ~osRtxAttrClass_Msk);
     3:   981:    thread->name          = name;
     -:   982:    thread->thread_next   = NULL;
     3:   983:    thread->thread_prev   = NULL;
     -:   984:    thread->delay_next    = NULL;
     -:   985:    thread->delay_prev    = NULL;
     -:   986:    thread->thread_join   = NULL;
     -:   987:    thread->delay         = 0U;
     3:   988:    thread->priority      = (int8_t)priority;
     3:   989:    thread->priority_base = (int8_t)priority;
     3:   990:    thread->stack_frame   = STACK_FRAME_INIT_VAL;
     -:   991:    thread->flags_options = 0U;
     3:   992:    thread->wait_flags    = 0U;
     -:   993:    thread->thread_flags  = 0U;
     -:   994:    thread->mutex_list    = NULL;
     3:   995:    thread->stack_mem     = stack_mem;
     3:   996:    thread->stack_size    = stack_size;
     3:   997:    thread->sp            = (uint32_t)stack_mem + stack_size - 64U;
     3:   998:    thread->thread_addr   = (uint32_t)func;
     -:   999:  #ifdef RTX_TZ_CONTEXT
     -:  1000:    thread->tz_memory     = tz_memory;
     -:  1001:  #endif
     -:  1002:  #ifdef RTX_SAFETY_CLASS
     -:  1003:    if ((attr_bits & osSafetyClass_Valid) != 0U) {
     -:  1004:      thread->attr       |= (uint8_t)((attr_bits & osSafetyClass_Msk) >>
     -:  1005:                                      (osSafetyClass_Pos - osRtxAttrClass_Pos));
     -:  1006:    } else {
     -:  1007:      // Inherit safety class from the running thread
     -:  1008:      if (thread_running != NULL) {
     -:  1009:        thread->attr     |= (uint8_t)(thread_running->attr & osRtxAttrClass_Msk);
     -:  1010:      }
     -:  1011:    }
     -:  1012:  #endif
     -:  1013:  #ifdef RTX_EXECUTION_ZONE
     -:  1014:    if ((attr_bits & osThreadZone_Valid) != 0U) {
     -:  1015:      thread->zone        = (uint8_t)((attr_bits & osThreadZone_Msk) >> osThreadZone_Pos);
     -:  1016:    } else {
     -:  1017:      // Inherit zone from the running thread
     -:  1018:      if (thread_running != NULL) {
     -:  1019:        thread->zone      = thread_running->zone;
     -:  1020:      } else {
     -:  1021:        thread->zone      = 0U;
     -:  1022:      }
     -:  1023:    }
     -:  1024:  #endif
     -:  1025:  #if defined(RTX_EXECUTION_ZONE) && defined(RTX_SAFETY_CLASS)
     -:  1026:    // Update class to zone assignment table
     -:  1027:    if (ThreadClassTable[thread->zone] == 0U) {
     -:  1028:      ThreadClassTable[thread->zone] = (uint8_t)(0x80U | (thread->attr >> osRtxAttrClass_Pos));
     -:  1029:    }
     -:  1030:  #endif
     -:  1031:  #ifdef RTX_THREAD_WATCHDOG
     -:  1032:    thread->wdog_next     = NULL;
     -:  1033:    thread->wdog_tick     = 0U;
     -:  1034:  #endif
     -:  1035:
     -:  1036:    // Initialize stack
     -:  1037:    //lint --e{613} false detection: "Possible use of null pointer"
     -:  1038:    ptr = (uint32_t *)stack_mem;
     3:  1039:    ptr[0] = osRtxStackMagicWord;
     3:  1040:    if ((osRtxConfig.flags & osRtxConfigStackWatermark) != 0U) {
 #####:  1041:      for (n = (stack_size/4U) - (16U + 1U); n != 0U; n--) {
     -:  1042:         ptr++;
 #####:  1043:        *ptr = osRtxStackFillPattern;
     -:  1044:      }
     -:  1045:    }
     3:  1046:    ptr = (uint32_t *)thread->sp;
     -:  1047:    for (n = 0U; n != 14U; n++) {
     3:  1048:      ptr[n] = 0U;                      // R4..R11, R0..R3, R12, LR
     -:  1049:    }
     3:  1050:    ptr[14] = (uint32_t)osThreadEntry;  // PC
     -:  1051:    ptr[15] = xPSR_InitVal(
     -:  1052:                (bool_t)((attr_bits & osThreadPrivileged) != 0U),
     -:  1053:                (bool_t)(((uint32_t)func & 1U) != 0U)
     -:  1054:              );                        // xPSR
     3:  1055:    ptr[8]  = (uint32_t)argument;       // R0
     -:  1056:    ptr[9]  = (uint32_t)func;           // R1
     -:  1057:
     -:  1058:    // Register post ISR processing function
     3:  1059:    osRtxInfo.post_process.thread = osRtxThreadPostProcess;
     -:  1060:
     3:  1061:    EvrRtxThreadCreated(thread, thread->thread_addr, thread->name);
     -:  1062:  } else {
 #####:  1063:    EvrRtxThreadError(NULL, (int32_t)osErrorNoMemory);
     -:  1064:  }
     -:  1065:
 #####:  1066:  if (thread != NULL) {
     3:  1067:    osRtxThreadDispatch(thread);
     -:  1068:  }
     -:  1069:
     -:  1070:  return thread;
     3:  1071:}
     -:  1072:
     -:  1073:/// Get name of a thread.
     -:  1074:/// \note API identical to osThreadGetName
     -:  1075:static const char *svcRtxThreadGetName (osThreadId_t thread_id) {
     -:  1076:  os_thread_t *thread = osRtxThreadId(thread_id);
     -:  1077:
     -:  1078:  // Check parameters
 #####:  1079:  if (!IsThreadPtrValid(thread) || (thread->id != osRtxIdThread)) {
     -:  1080:    EvrRtxThreadGetName(thread, NULL);
     -:  1081:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:  1082:    return NULL;
     -:  1083:  }
     -:  1084:
     -:  1085:  EvrRtxThreadGetName(thread, thread->name);
     -:  1086:
     -:  1087:  return thread->name;
     -:  1088:}
     -:  1089:
     -:  1090:/// Get safety class of a thread.
     -:  1091:/// \note API identical to osThreadGetClass
     -:  1092:static uint32_t svcRtxThreadGetClass (osThreadId_t thread_id) {
     -:  1093:#ifdef RTX_SAFETY_CLASS
     -:  1094:  os_thread_t *thread = osRtxThreadId(thread_id);
     -:  1095:
     -:  1096:  // Check parameters
     -:  1097:  if (!IsThreadPtrValid(thread) || (thread->id != osRtxIdThread)) {
     -:  1098:    EvrRtxThreadGetClass(thread, osErrorId);
     -:  1099:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:  1100:    return osErrorId;
     -:  1101:  }
     -:  1102:
     -:  1103:  EvrRtxThreadGetClass(thread, (uint32_t)thread->attr >> osRtxAttrClass_Pos);
     -:  1104:
     -:  1105:  return ((uint32_t)thread->attr >> osRtxAttrClass_Pos);
     -:  1106:#else
     -:  1107:  (void)thread_id;
     -:  1108:  return osErrorId;
     -:  1109:#endif
     -:  1110:}
     -:  1111:
     -:  1112:/// Get zone of a thread.
     -:  1113:/// \note API identical to osThreadGetZone
     -:  1114:static uint32_t svcRtxThreadGetZone (osThreadId_t thread_id) {
     -:  1115:#ifdef RTX_EXECUTION_ZONE
     -:  1116:  os_thread_t *thread = osRtxThreadId(thread_id);
     -:  1117:
     -:  1118:  // Check parameters
     -:  1119:  if (!IsThreadPtrValid(thread) || (thread->id != osRtxIdThread)) {
     -:  1120:    EvrRtxThreadGetZone(thread, osErrorId);
     -:  1121:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:  1122:    return osErrorId;
     -:  1123:  }
     -:  1124:
     -:  1125:  EvrRtxThreadGetZone(thread, thread->zone);
     -:  1126:
     -:  1127:  return thread->zone;
     -:  1128:#else
     -:  1129:  (void)thread_id;
     -:  1130:  return osErrorId;
     -:  1131:#endif
     -:  1132:}
     -:  1133:
     -:  1134:/// Return the thread ID of the current running thread.
     -:  1135:/// \note API identical to osThreadGetId
 #####:  1136:static osThreadId_t svcRtxThreadGetId (void) {
     -:  1137:  os_thread_t *thread;
     -:  1138:
     -:  1139:  thread = osRtxThreadGetRunning();
 #####:  1140:  EvrRtxThreadGetId(thread);
 #####:  1141:  return thread;
     -:  1142:}
     -:  1143:
     -:  1144:/// Get current thread state of a thread.
     -:  1145:/// \note API identical to osThreadGetState
     -:  1146:static osThreadState_t svcRtxThreadGetState (osThreadId_t thread_id) {
     -:  1147:  os_thread_t    *thread = osRtxThreadId(thread_id);
     -:  1148:  osThreadState_t state;
     -:  1149:
     -:  1150:  // Check parameters
     -:  1151:  if (!IsThreadPtrValid(thread) || (thread->id != osRtxIdThread)) {
     -:  1152:    EvrRtxThreadGetState(thread, osThreadError);
     -:  1153:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:  1154:    return osThreadError;
     -:  1155:  }
     -:  1156:
     -:  1157:  state = osRtxThreadState(thread);
     -:  1158:
     -:  1159:  EvrRtxThreadGetState(thread, state);
     -:  1160:
     -:  1161:  return state;
     -:  1162:}
     -:  1163:
     -:  1164:/// Get stack size of a thread.
     -:  1165:/// \note API identical to osThreadGetStackSize
     -:  1166:static uint32_t svcRtxThreadGetStackSize (osThreadId_t thread_id) {
     -:  1167:  os_thread_t *thread = osRtxThreadId(thread_id);
     -:  1168:
     -:  1169:  // Check parameters
     -:  1170:  if (!IsThreadPtrValid(thread) || (thread->id != osRtxIdThread)) {
     -:  1171:    EvrRtxThreadGetStackSize(thread, 0U);
     -:  1172:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:  1173:    return 0U;
     -:  1174:  }
     -:  1175:
     -:  1176:  EvrRtxThreadGetStackSize(thread, thread->stack_size);
     -:  1177:
     -:  1178:  return thread->stack_size;
     -:  1179:}
     -:  1180:
     -:  1181:/// Get available stack space of a thread based on stack watermark recording during execution.
     -:  1182:/// \note API identical to osThreadGetStackSpace
     -:  1183:static uint32_t svcRtxThreadGetStackSpace (osThreadId_t thread_id) {
     -:  1184:  os_thread_t    *thread = osRtxThreadId(thread_id);
     -:  1185:  const uint32_t *stack;
     -:  1186:        uint32_t  space;
     -:  1187:
     -:  1188:  // Check parameters
     -:  1189:  if (!IsThreadPtrValid(thread) || (thread->id != osRtxIdThread)) {
     -:  1190:    EvrRtxThreadGetStackSpace(thread, 0U);
     -:  1191:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:  1192:    return 0U;
     -:  1193:  }
     -:  1194:
     -:  1195:  // Check if stack watermark is not enabled
     -:  1196:  if ((osRtxConfig.flags & osRtxConfigStackWatermark) == 0U) {
     -:  1197:    EvrRtxThreadGetStackSpace(thread, 0U);
     -:  1198:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:  1199:    return 0U;
     -:  1200:  }
     -:  1201:
     -:  1202:  //lint -e{9079} "conversion from pointer to void to pointer to other type"
     -:  1203:  stack = thread->stack_mem;
     -:  1204:  if (*stack++ == osRtxStackMagicWord) {
     -:  1205:    for (space = 4U; space < thread->stack_size; space += 4U) {
     -:  1206:      if (*stack++ != osRtxStackFillPattern) {
     -:  1207:        break;
     -:  1208:      }
     -:  1209:    }
     -:  1210:  } else {
     -:  1211:    space = 0U;
     -:  1212:  }
     -:  1213:
 #####:  1214:  EvrRtxThreadGetStackSpace(thread, space);
     -:  1215:
     -:  1216:  return space;
     -:  1217:}
     -:  1218:
     -:  1219:/// Change priority of a thread.
     -:  1220:/// \note API identical to osThreadSetPriority
     -:  1221:static osStatus_t svcRtxThreadSetPriority (osThreadId_t thread_id, osPriority_t priority) {
     -:  1222:  os_thread_t       *thread = osRtxThreadId(thread_id);
     -:  1223:#ifdef RTX_SAFETY_CLASS
     -:  1224:  const os_thread_t *thread_running;
     -:  1225:#endif
     -:  1226:
     -:  1227:  // Check parameters
     -:  1228:  if (!IsThreadPtrValid(thread) || (thread->id != osRtxIdThread) ||
     -:  1229:      (priority < osPriorityIdle) || (priority > osPriorityISR)) {
     -:  1230:    EvrRtxThreadError(thread, (int32_t)osErrorParameter);
     -:  1231:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:  1232:    return osErrorParameter;
     -:  1233:  }
     -:  1234:
     -:  1235:#ifdef RTX_SAFETY_CLASS
     -:  1236:  // Check running thread safety class
     -:  1237:  thread_running = osRtxThreadGetRunning();
     -:  1238:  if ((thread_running != NULL) &&
     -:  1239:      ((thread_running->attr >> osRtxAttrClass_Pos) < (thread->attr >> osRtxAttrClass_Pos))) {
     -:  1240:    EvrRtxThreadError(thread, (int32_t)osErrorSafetyClass);
     -:  1241:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:  1242:    return osErrorSafetyClass;
     -:  1243:  }
     -:  1244:#endif
     -:  1245:
     -:  1246:  // Check object state
     -:  1247:  if (thread->state == osRtxThreadTerminated) {
     -:  1248:    EvrRtxThreadError(thread, (int32_t)osErrorResource);
     -:  1249:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:  1250:    return osErrorResource;
     -:  1251:  }
     -:  1252:
     -:  1253:  if (thread->priority   != (int8_t)priority) {
 #####:  1254:    thread->priority      = (int8_t)priority;
     -:  1255:    thread->priority_base = (int8_t)priority;
 #####:  1256:    EvrRtxThreadPriorityUpdated(thread, priority);
     -:  1257:    osRtxThreadListSort(thread);
 #####:  1258:    osRtxThreadDispatch(NULL);
     -:  1259:  }
     -:  1260:
     -:  1261:  return osOK;
 #####:  1262:}
     -:  1263:
     -:  1264:/// Get current priority of a thread.
     -:  1265:/// \note API identical to osThreadGetPriority
     -:  1266:static osPriority_t svcRtxThreadGetPriority (osThreadId_t thread_id) {
     -:  1267:  os_thread_t *thread = osRtxThreadId(thread_id);
     -:  1268:  osPriority_t priority;
     -:  1269:
     -:  1270:  // Check parameters
     -:  1271:  if (!IsThreadPtrValid(thread) || (thread->id != osRtxIdThread)) {
     -:  1272:    EvrRtxThreadGetPriority(thread, osPriorityError);
     -:  1273:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:  1274:    return osPriorityError;
     -:  1275:  }
     -:  1276:
     -:  1277:  // Check object state
     -:  1278:  if (thread->state == osRtxThreadTerminated) {
     -:  1279:    EvrRtxThreadGetPriority(thread, osPriorityError);
     -:  1280:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:  1281:    return osPriorityError;
     -:  1282:  }
     -:  1283:
     -:  1284:  priority = osRtxThreadPriority(thread);
     -:  1285:
     -:  1286:  EvrRtxThreadGetPriority(thread, priority);
     -:  1287:
     -:  1288:  return priority;
     -:  1289:}
     -:  1290:
     -:  1291:/// Pass control to next thread that is in state READY.
     -:  1292:/// \note API identical to osThreadYield
     -:  1293:static osStatus_t svcRtxThreadYield (void) {
     -:  1294:  os_thread_t *thread_running;
     -:  1295:  os_thread_t *thread_ready;
     -:  1296:
     -:  1297:  if (osRtxKernelGetState() == osRtxKernelRunning) {
     -:  1298:    thread_running = osRtxThreadGetRunning();
     -:  1299:    thread_ready   = osRtxInfo.thread.ready.thread_list;
     -:  1300:    if ((thread_ready != NULL) &&
     -:  1301:        (thread_ready->priority == thread_running->priority)) {
     -:  1302:      osRtxThreadListRemove(thread_ready);
     -:  1303:      osRtxThreadReadyPut(thread_running);
 #####:  1304:      EvrRtxThreadPreempted(thread_running);
     -:  1305:      osRtxThreadSwitch(thread_ready);
     -:  1306:    }
     -:  1307:  }
     -:  1308:
 #####:  1309:  return osOK;
     -:  1310:}
     -:  1311:
     -:  1312:/// Suspend execution of a thread.
     -:  1313:/// \note API identical to osThreadSuspend
     -:  1314:static osStatus_t svcRtxThreadSuspend (osThreadId_t thread_id) {
     -:  1315:  os_thread_t       *thread = osRtxThreadId(thread_id);
     -:  1316:#ifdef RTX_SAFETY_CLASS
     -:  1317:  const os_thread_t *thread_running;
     -:  1318:#endif
     -:  1319:  osStatus_t         status;
     -:  1320:
     -:  1321:  // Check parameters
     -:  1322:  if (!IsThreadPtrValid(thread) || (thread->id != osRtxIdThread)) {
     -:  1323:    EvrRtxThreadError(thread, (int32_t)osErrorParameter);
     -:  1324:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:  1325:    return osErrorParameter;
     -:  1326:  }
     -:  1327:
     -:  1328:#ifdef RTX_SAFETY_CLASS
     -:  1329:  // Check running thread safety class
     -:  1330:  thread_running = osRtxThreadGetRunning();
     -:  1331:  if ((thread_running != NULL) &&
     -:  1332:      ((thread_running->attr >> osRtxAttrClass_Pos) < (thread->attr >> osRtxAttrClass_Pos))) {
     -:  1333:    EvrRtxThreadError(thread, (int32_t)osErrorSafetyClass);
     -:  1334:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:  1335:    return osErrorSafetyClass;
     -:  1336:  }
     -:  1337:#endif
     -:  1338:
     -:  1339:  // Check object state
     -:  1340:  switch (thread->state & osRtxThreadStateMask) {
     -:  1341:    case osRtxThreadRunning:
     -:  1342:      if ((osRtxKernelGetState() != osRtxKernelRunning) ||
     -:  1343:          (osRtxInfo.thread.ready.thread_list == NULL)) {
     -:  1344:        EvrRtxThreadError(thread, (int32_t)osErrorResource);
     -:  1345:        status = osErrorResource;
     -:  1346:      } else {
     -:  1347:        status = osOK;
     -:  1348:      }
     -:  1349:      break;
     -:  1350:    case osRtxThreadReady:
     -:  1351:      osRtxThreadListRemove(thread);
     -:  1352:      status = osOK;
     -:  1353:      break;
     -:  1354:    case osRtxThreadBlocked:
     -:  1355:      osRtxThreadListRemove(thread);
     -:  1356:      osRtxThreadDelayRemove(thread);
     -:  1357:      status = osOK;
     -:  1358:      break;
     -:  1359:    case osRtxThreadInactive:
     -:  1360:    case osRtxThreadTerminated:
     -:  1361:    default:
     -:  1362:      EvrRtxThreadError(thread, (int32_t)osErrorResource);
     -:  1363:      status = osErrorResource;
     -:  1364:      break;
     -:  1365:  }
     -:  1366:
 #####:  1367:  if (status == osOK) {
 #####:  1368:    EvrRtxThreadSuspended(thread);
     -:  1369:
 #####:  1370:    if (thread->state == osRtxThreadRunning) {
     -:  1371:      osRtxThreadSwitch(osRtxThreadListGet(&osRtxInfo.thread.ready));
     -:  1372:    }
     -:  1373:
     -:  1374:    // Update Thread State and put it into Delay list
 #####:  1375:    thread->state = osRtxThreadBlocked;
     -:  1376:    osRtxThreadDelayInsert(thread, osWaitForever);
     -:  1377:  }
     -:  1378:
     -:  1379:  return status;
 #####:  1380:}
     -:  1381:
     -:  1382:/// Resume execution of a thread.
     -:  1383:/// \note API identical to osThreadResume
     -:  1384:static osStatus_t svcRtxThreadResume (osThreadId_t thread_id) {
     -:  1385:  os_thread_t       *thread = osRtxThreadId(thread_id);
     -:  1386:#ifdef RTX_SAFETY_CLASS
     -:  1387:  const os_thread_t *thread_running;
     -:  1388:#endif
     -:  1389:
     -:  1390:  // Check parameters
     -:  1391:  if (!IsThreadPtrValid(thread) || (thread->id != osRtxIdThread)) {
     -:  1392:    EvrRtxThreadError(thread, (int32_t)osErrorParameter);
     -:  1393:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:  1394:    return osErrorParameter;
     -:  1395:  }
     -:  1396:
     -:  1397:#ifdef RTX_SAFETY_CLASS
     -:  1398:  // Check running thread safety class
     -:  1399:  thread_running = osRtxThreadGetRunning();
     -:  1400:  if ((thread_running != NULL) &&
     -:  1401:      ((thread_running->attr >> osRtxAttrClass_Pos) < (thread->attr >> osRtxAttrClass_Pos))) {
     -:  1402:    EvrRtxThreadError(thread, (int32_t)osErrorSafetyClass);
     -:  1403:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:  1404:    return osErrorSafetyClass;
     -:  1405:  }
     -:  1406:#endif
     -:  1407:
     -:  1408:  // Check object state
     -:  1409:  if ((thread->state & osRtxThreadStateMask) != osRtxThreadBlocked) {
     -:  1410:    EvrRtxThreadError(thread, (int32_t)osErrorResource);
     -:  1411:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:  1412:    return osErrorResource;
     -:  1413:  }
     -:  1414:
     -:  1415:  EvrRtxThreadResumed(thread);
     -:  1416:
     -:  1417:  // Wakeup Thread
     -:  1418:  osRtxThreadListRemove(thread);
     -:  1419:  osRtxThreadDelayRemove(thread);
     -:  1420:  osRtxThreadDispatch(thread);
     -:  1421:
     -:  1422:  return osOK;
 #####:  1423:}
     -:  1424:
     -:  1425:/// Wakeup a thread waiting to join.
     -:  1426:/// \param[in]  thread          thread object.
     -:  1427:void osRtxThreadJoinWakeup (const os_thread_t *thread) {
     -:  1428:
 #####:  1429:  if (thread->thread_join != NULL) {
 #####:  1430:    osRtxThreadWaitExit(thread->thread_join, (uint32_t)osOK, FALSE);
 #####:  1431:    EvrRtxThreadJoined(thread->thread_join);
     -:  1432:  }
 #####:  1433:  if (thread->state == osRtxThreadWaitingJoin) {
 #####:  1434:    thread->thread_next->thread_join = NULL;
     -:  1435:  }
 #####:  1436:}
     -:  1437:
     -:  1438:/// Free Thread resources.
     -:  1439:/// \param[in]  thread          thread object.
     1:  1440:static void osRtxThreadFree (os_thread_t *thread) {
     -:  1441:
     1:  1442:  osRtxThreadBeforeFree(thread);
     -:  1443:
     -:  1444:  // Mark object as inactive and invalid
     -:  1445:  thread->state = osRtxThreadInactive;
     1:  1446:  thread->id    = osRtxIdInvalid;
     -:  1447:
     -:  1448:#ifdef RTX_TZ_CONTEXT
     -:  1449:  // Free secure process stack
     -:  1450:  if (thread->tz_memory != 0U) {
     -:  1451:    (void)TZ_FreeModuleContext_S(thread->tz_memory);
     -:  1452:  }
     -:  1453:#endif
     -:  1454:
     -:  1455:  // Free stack memory
     1:  1456:  if ((thread->flags & osRtxFlagSystemMemory) != 0U) {
     1:  1457:    if ((thread->flags & osRtxThreadFlagDefStack) != 0U) {
 #####:  1458:      (void)osRtxMemoryPoolFree(osRtxInfo.mpi.stack, thread->stack_mem);
     -:  1459:    } else {
     1:  1460:      (void)osRtxMemoryFree(osRtxInfo.mem.stack, thread->stack_mem);
     -:  1461:    }
     -:  1462:  }
     -:  1463:
     -:  1464:  // Free object memory
     1:  1465:  if ((thread->flags & osRtxFlagSystemObject) != 0U) {
     -:  1466:#ifdef RTX_OBJ_PTR_CHECK
     -:  1467:    (void)osRtxMemoryPoolFree(osRtxInfo.mpi.thread, thread);
     -:  1468:#else
     1:  1469:    if (osRtxInfo.mpi.thread != NULL) {
 #####:  1470:      (void)osRtxMemoryPoolFree(osRtxInfo.mpi.thread, thread);
     -:  1471:    } else {
     1:  1472:      (void)osRtxMemoryFree(osRtxInfo.mem.common, thread);
     -:  1473:    }
     -:  1474:#endif
     -:  1475:#ifdef RTX_OBJ_MEM_USAGE
     -:  1476:    osRtxThreadMemUsage.cnt_free++;
     -:  1477:#endif
     -:  1478:  }
     1:  1479:}
     -:  1480:
     -:  1481:/// Destroy a Thread.
     -:  1482:/// \param[in]  thread          thread object.
     -:  1483:void osRtxThreadDestroy (os_thread_t *thread) {
     -:  1484:
 #####:  1485:  if ((thread->attr & osThreadJoinable) == 0U) {
 #####:  1486:    osRtxThreadFree(thread);
 #####:  1487:  } else {
     -:  1488:    // Update Thread State and put it into Terminate Thread list
 #####:  1489:    thread->state = osRtxThreadTerminated;
 #####:  1490:    thread->thread_prev = NULL;
 #####:  1491:    thread->thread_next = osRtxInfo.thread.terminate_list;
 #####:  1492:    if (osRtxInfo.thread.terminate_list != NULL) {
 #####:  1493:      osRtxInfo.thread.terminate_list->thread_prev = thread;
     -:  1494:    }
 #####:  1495:    osRtxInfo.thread.terminate_list = thread;
     -:  1496:  }
 #####:  1497:  EvrRtxThreadDestroyed(thread);
     -:  1498:}
     -:  1499:
     -:  1500:/// Detach a thread (thread storage can be reclaimed when thread terminates).
     -:  1501:/// \note API identical to osThreadDetach
     -:  1502:static osStatus_t svcRtxThreadDetach (osThreadId_t thread_id) {
     -:  1503:  os_thread_t       *thread = osRtxThreadId(thread_id);
     -:  1504:#ifdef RTX_SAFETY_CLASS
     -:  1505:  const os_thread_t *thread_running;
     -:  1506:#endif
     -:  1507:
     -:  1508:  // Check parameters
     -:  1509:  if (!IsThreadPtrValid(thread) || (thread->id != osRtxIdThread)) {
     -:  1510:    EvrRtxThreadError(thread, (int32_t)osErrorParameter);
     -:  1511:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:  1512:    return osErrorParameter;
     -:  1513:  }
     -:  1514:
     -:  1515:#ifdef RTX_SAFETY_CLASS
     -:  1516:  // Check running thread safety class
     -:  1517:  thread_running = osRtxThreadGetRunning();
     -:  1518:  if ((thread_running != NULL) &&
     -:  1519:      ((thread_running->attr >> osRtxAttrClass_Pos) < (thread->attr >> osRtxAttrClass_Pos))) {
     -:  1520:    EvrRtxThreadError(thread, (int32_t)osErrorSafetyClass);
     -:  1521:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:  1522:    return osErrorSafetyClass;
     -:  1523:  }
     -:  1524:#endif
     -:  1525:
     -:  1526:  // Check object attributes
     -:  1527:  if ((thread->attr & osThreadJoinable) == 0U) {
     -:  1528:    EvrRtxThreadError(thread, osRtxErrorThreadNotJoinable);
     -:  1529:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:  1530:    return osErrorResource;
     -:  1531:  }
     -:  1532:
     -:  1533:  if (thread->state == osRtxThreadTerminated) {
     -:  1534:    osRtxThreadListUnlink(&osRtxInfo.thread.terminate_list, thread);
     -:  1535:    osRtxThreadFree(thread);
     -:  1536:  } else {
     -:  1537:    thread->attr &= ~osThreadJoinable;
     -:  1538:  }
     -:  1539:
     -:  1540:  EvrRtxThreadDetached(thread);
     -:  1541:
     -:  1542:  return osOK;
     -:  1543:}
     -:  1544:
     -:  1545:/// Wait for specified thread to terminate.
     -:  1546:/// \note API identical to osThreadJoin
     -:  1547:static osStatus_t svcRtxThreadJoin (osThreadId_t thread_id) {
     -:  1548:  os_thread_t *thread = osRtxThreadId(thread_id);
     -:  1549:  os_thread_t *thread_running;
     -:  1550:  osStatus_t   status;
     -:  1551:
     -:  1552:  // Check parameters
     -:  1553:  if (!IsThreadPtrValid(thread) || (thread->id != osRtxIdThread)) {
     -:  1554:    EvrRtxThreadError(thread, (int32_t)osErrorParameter);
     -:  1555:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:  1556:    return osErrorParameter;
     -:  1557:  }
     -:  1558:
     -:  1559:#ifdef RTX_SAFETY_CLASS
     -:  1560:  // Check running thread safety class
     -:  1561:  thread_running = osRtxThreadGetRunning();
     -:  1562:  if ((thread_running != NULL) &&
     -:  1563:      ((thread_running->attr >> osRtxAttrClass_Pos) < (thread->attr >> osRtxAttrClass_Pos))) {
     -:  1564:    EvrRtxThreadError(thread, (int32_t)osErrorSafetyClass);
     -:  1565:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:  1566:    return osErrorSafetyClass;
     -:  1567:  }
     -:  1568:#endif
     -:  1569:
     -:  1570:  // Check object attributes
     -:  1571:  if ((thread->attr & osThreadJoinable) == 0U) {
     -:  1572:    EvrRtxThreadError(thread, osRtxErrorThreadNotJoinable);
     -:  1573:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:  1574:    return osErrorResource;
     -:  1575:  }
     -:  1576:
     -:  1577:  // Check object state
     -:  1578:  if (thread->state == osRtxThreadRunning) {
     -:  1579:    EvrRtxThreadError(thread, (int32_t)osErrorResource);
     -:  1580:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:  1581:    return osErrorResource;
     -:  1582:  }
     -:  1583:
     -:  1584:  if (thread->state == osRtxThreadTerminated) {
     -:  1585:    osRtxThreadListUnlink(&osRtxInfo.thread.terminate_list, thread);
 #####:  1586:    osRtxThreadFree(thread);
 #####:  1587:    EvrRtxThreadJoined(thread);
     -:  1588:    status = osOK;
 #####:  1589:  } else {
     -:  1590:    // Suspend current Thread
     -:  1591:    if (osRtxThreadWaitEnter(osRtxThreadWaitingJoin, osWaitForever)) {
     -:  1592:      thread_running = osRtxThreadGetRunning();
 #####:  1593:      thread_running->thread_next = thread;
 #####:  1594:      thread->thread_join = thread_running;
 #####:  1595:      thread->attr &= ~osThreadJoinable;
 #####:  1596:      EvrRtxThreadJoinPending(thread);
     -:  1597:    } else {
     -:  1598:      EvrRtxThreadError(thread, (int32_t)osErrorResource);
     -:  1599:    }
     -:  1600:    status = osErrorResource;
     -:  1601:  }
     -:  1602:
     -:  1603:  return status;
     -:  1604:}
     -:  1605:
     -:  1606:/// Terminate execution of current running thread.
     -:  1607:/// \note API identical to osThreadExit
     1:  1608:static void svcRtxThreadExit (void) {
     -:  1609:  os_thread_t *thread;
     -:  1610:
     -:  1611:  // Check if switch to next Ready Thread is possible
     1:  1612:  if ((osRtxKernelGetState() != osRtxKernelRunning) ||
     -:  1613:      (osRtxInfo.thread.ready.thread_list == NULL)) {
     -:  1614:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:  1615:    return;
     -:  1616:  }
     -:  1617:
     -:  1618:  // Get running thread
     -:  1619:  thread = osRtxThreadGetRunning();
     -:  1620:
     -:  1621:#ifdef RTX_THREAD_WATCHDOG
     -:  1622:  // Remove Thread from the Watchdog list
     -:  1623:  osRtxThreadWatchdogRemove(thread);
     -:  1624:#endif
     -:  1625:
     -:  1626:  // Release owned Mutexes
     1:  1627:  osRtxMutexOwnerRelease(thread->mutex_list);
     -:  1628:
     -:  1629:  // Wakeup Thread waiting to Join
     -:  1630:  osRtxThreadJoinWakeup(thread);
     -:  1631:
     -:  1632:  // Switch to next Ready Thread
     -:  1633:  osRtxThreadSwitch(osRtxThreadListGet(&osRtxInfo.thread.ready));
     -:  1634:
     -:  1635:  // Update Stack Pointer
     1:  1636:  thread->sp = __get_PSP();
     -:  1637:#ifdef RTX_STACK_CHECK
     -:  1638:  // Check Stack usage
     1:  1639:  if (!osRtxThreadStackCheck(thread)) {
 #####:  1640:    osRtxThreadSetRunning(osRtxInfo.thread.run.next);
 #####:  1641:    (void)osRtxKernelErrorNotify(osRtxErrorStackOverflow, thread);
     -:  1642:  }
     -:  1643:#endif
     -:  1644:
     -:  1645:  // Mark running thread as deleted
     -:  1646:  osRtxThreadSetRunning(NULL);
     -:  1647:
     -:  1648:  // Destroy Thread
     -:  1649:  osRtxThreadDestroy(thread);
     1:  1650:}
     -:  1651:
     -:  1652:/// Terminate execution of a thread.
     -:  1653:/// \note API identical to osThreadTerminate
     -:  1654:static osStatus_t svcRtxThreadTerminate (osThreadId_t thread_id) {
     -:  1655:  os_thread_t       *thread = osRtxThreadId(thread_id);
     -:  1656:#ifdef RTX_SAFETY_CLASS
     -:  1657:  const os_thread_t *thread_running;
     -:  1658:#endif
     -:  1659:  osStatus_t         status;
     -:  1660:
     -:  1661:  // Check parameters
     -:  1662:  if (!IsThreadPtrValid(thread) || (thread->id != osRtxIdThread)) {
     -:  1663:    EvrRtxThreadError(thread, (int32_t)osErrorParameter);
     -:  1664:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:  1665:    return osErrorParameter;
     -:  1666:  }
     -:  1667:
     -:  1668:#ifdef RTX_SAFETY_CLASS
     -:  1669:  // Check running thread safety class
     -:  1670:  thread_running = osRtxThreadGetRunning();
     -:  1671:  if ((thread_running != NULL) &&
     -:  1672:      ((thread_running->attr >> osRtxAttrClass_Pos) < (thread->attr >> osRtxAttrClass_Pos))) {
     -:  1673:    EvrRtxThreadError(thread, (int32_t)osErrorSafetyClass);
     -:  1674:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:  1675:    return osErrorSafetyClass;
     -:  1676:  }
     -:  1677:#endif
     -:  1678:
     -:  1679:  // Check object state
     -:  1680:  switch (thread->state & osRtxThreadStateMask) {
     -:  1681:    case osRtxThreadRunning:
     -:  1682:      if ((osRtxKernelGetState() != osRtxKernelRunning) ||
     -:  1683:          (osRtxInfo.thread.ready.thread_list == NULL)) {
     -:  1684:        EvrRtxThreadError(thread, (int32_t)osErrorResource);
     -:  1685:        status = osErrorResource;
     -:  1686:      } else {
     -:  1687:        status = osOK;
     -:  1688:      }
     -:  1689:      break;
     -:  1690:    case osRtxThreadReady:
     -:  1691:      osRtxThreadListRemove(thread);
     -:  1692:      status = osOK;
     -:  1693:      break;
     -:  1694:    case osRtxThreadBlocked:
     -:  1695:      osRtxThreadListRemove(thread);
     -:  1696:      osRtxThreadDelayRemove(thread);
     -:  1697:      status = osOK;
     -:  1698:      break;
     -:  1699:    case osRtxThreadInactive:
     -:  1700:    case osRtxThreadTerminated:
     -:  1701:    default:
     -:  1702:      EvrRtxThreadError(thread, (int32_t)osErrorResource);
     -:  1703:      status = osErrorResource;
     -:  1704:      break;
     -:  1705:  }
     -:  1706:
 #####:  1707:  if (status == osOK) {
     -:  1708:#ifdef RTX_THREAD_WATCHDOG
     -:  1709:    // Remove Thread from the Watchdog list
     -:  1710:    osRtxThreadWatchdogRemove(thread);
     -:  1711:#endif
     -:  1712:
     -:  1713:    // Release owned Mutexes
     -:  1714:    osRtxMutexOwnerRelease(thread->mutex_list);
     -:  1715:
     -:  1716:    // Wakeup Thread waiting to Join
     -:  1717:    osRtxThreadJoinWakeup(thread);
     -:  1718:
     -:  1719:    // Switch to next Ready Thread when terminating running Thread
     -:  1720:    if (thread->state == osRtxThreadRunning) {
     -:  1721:      osRtxThreadSwitch(osRtxThreadListGet(&osRtxInfo.thread.ready));
     -:  1722:      // Update Stack Pointer
     -:  1723:      thread->sp = __get_PSP();
     -:  1724:#ifdef RTX_STACK_CHECK
     -:  1725:      // Check Stack usage
 #####:  1726:      if (!osRtxThreadStackCheck(thread)) {
 #####:  1727:        osRtxThreadSetRunning(osRtxInfo.thread.run.next);
 #####:  1728:        (void)osRtxKernelErrorNotify(osRtxErrorStackOverflow, thread);
     -:  1729:      }
     -:  1730:#endif
     -:  1731:      // Mark running thread as deleted
     -:  1732:      osRtxThreadSetRunning(NULL);
     -:  1733:    } else {
     -:  1734:      osRtxThreadDispatch(NULL);
     -:  1735:    }
     -:  1736:
     -:  1737:    // Destroy Thread
     -:  1738:    osRtxThreadDestroy(thread);
     -:  1739:  }
     -:  1740:
     -:  1741:  return status;
 #####:  1742:}
     -:  1743:
     -:  1744:/// Feed watchdog of the current running thread.
     -:  1745:/// \note API identical to osThreadFeedWatchdog
     -:  1746:static osStatus_t svcRtxThreadFeedWatchdog (uint32_t ticks) {
     -:  1747:#ifdef RTX_THREAD_WATCHDOG
     -:  1748:  os_thread_t *thread;
     -:  1749:
     -:  1750:  // Check running thread
     -:  1751:  thread = osRtxThreadGetRunning();
     -:  1752:  if (thread == NULL) {
     -:  1753:    EvrRtxThreadError(NULL, osRtxErrorKernelNotRunning);
     -:  1754:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:  1755:    return osError;
     -:  1756:  }
     -:  1757:
     -:  1758:  osRtxThreadWatchdogRemove(thread);
     -:  1759:  osRtxThreadWatchdogInsert(thread, ticks);
     -:  1760:
     -:  1761:  EvrRtxThreadFeedWatchdogDone();
     -:  1762:
     -:  1763:  return osOK;
     -:  1764:#else
     -:  1765:  (void)ticks;
     -:  1766:  return osError;
     -:  1767:#endif
     -:  1768:}
     -:  1769:
     -:  1770:/// Protect the creation of privileged threads.
     -:  1771:/// \note API identical to osThreadProtectPrivileged
     -:  1772:static osStatus_t svcRtxThreadProtectPrivileged (void) {
     -:  1773:#ifdef RTX_SAFETY_FEATURES
     -:  1774:
     -:  1775:  // Check that Kernel is initialized
     -:  1776:  if (osRtxKernelGetState() == osRtxKernelInactive) {
     -:  1777:    EvrRtxThreadError(NULL, osRtxErrorKernelNotReady);
     -:  1778:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:  1779:    return osError;
     -:  1780:  }
     -:  1781:
     -:  1782:  osRtxInfo.kernel.protect |= osRtxKernelProtectPrivileged;
     -:  1783:
     -:  1784:  EvrRtxThreadPrivilegedProtected();
     -:  1785:
     -:  1786:  return osOK;
     -:  1787:#else
     -:  1788:  return osError;
     -:  1789:#endif
     -:  1790:}
     -:  1791:
     -:  1792:/// Suspend execution of threads for specified safety classes.
     -:  1793:/// \note API identical to osThreadSuspendClass
     -:  1794:static osStatus_t svcRtxThreadSuspendClass (uint32_t safety_class, uint32_t mode) {
     -:  1795:#ifdef RTX_SAFETY_CLASS
     -:  1796:  os_thread_t *thread;
     -:  1797:  os_thread_t *thread_next;
     -:  1798:
     -:  1799:  // Check parameters
     -:  1800:  if (safety_class > 0x0FU) {
     -:  1801:    EvrRtxThreadError(NULL, (int32_t)osErrorParameter);
     -:  1802:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:  1803:    return osErrorParameter;
     -:  1804:  }
     -:  1805:
     -:  1806:  // Check running thread safety class (when called from thread)
     -:  1807:  thread = osRtxThreadGetRunning();
     -:  1808:  if ((thread != NULL) && IsSVCallIrq()) {
     -:  1809:    if ((((mode & osSafetyWithSameClass)  != 0U) &&
     -:  1810:         ((thread->attr >> osRtxAttrClass_Pos) < (uint8_t)safety_class)) ||
     -:  1811:        (((mode & osSafetyWithLowerClass) != 0U) &&
     -:  1812:         (((thread->attr >> osRtxAttrClass_Pos) + 1U) < (uint8_t)safety_class))) {
     -:  1813:      EvrRtxThreadError(NULL, (int32_t)osErrorSafetyClass);
     -:  1814:      //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:  1815:      return osErrorSafetyClass;
     -:  1816:    }
     -:  1817:  }
     -:  1818:
     -:  1819:  // Threads in Wait List
     -:  1820:  thread = osRtxInfo.thread.wait_list;
     -:  1821:  while (thread != NULL) {
     -:  1822:    thread_next = thread->delay_next;
     -:  1823:    if ((((mode & osSafetyWithSameClass)  != 0U) &&
     -:  1824:         ((thread->attr >> osRtxAttrClass_Pos) == (uint8_t)safety_class)) ||
     -:  1825:        (((mode & osSafetyWithLowerClass) != 0U) &&
     -:  1826:         ((thread->attr >> osRtxAttrClass_Pos) <  (uint8_t)safety_class))) {
     -:  1827:      osRtxThreadListRemove(thread);
     -:  1828:      thread->state = osRtxThreadBlocked;
     -:  1829:      EvrRtxThreadSuspended(thread);
     -:  1830:    }
     -:  1831:    thread = thread_next;
     -:  1832:  }
     -:  1833:
     -:  1834:  // Threads in Delay List
     -:  1835:  thread = osRtxInfo.thread.delay_list;
     -:  1836:  while (thread != NULL) {
     -:  1837:    thread_next = thread->delay_next;
     -:  1838:    if ((((mode & osSafetyWithSameClass)  != 0U) &&
     -:  1839:         ((thread->attr >> osRtxAttrClass_Pos) == (uint8_t)safety_class)) ||
     -:  1840:        (((mode & osSafetyWithLowerClass) != 0U) &&
     -:  1841:         ((thread->attr >> osRtxAttrClass_Pos) <  (uint8_t)safety_class))) {
     -:  1842:      osRtxThreadListRemove(thread);
     -:  1843:      osRtxThreadDelayRemove(thread);
     -:  1844:      thread->state = osRtxThreadBlocked;
     -:  1845:      osRtxThreadDelayInsert(thread, osWaitForever);
     -:  1846:      EvrRtxThreadSuspended(thread);
     -:  1847:    }
     -:  1848:    thread = thread_next;
     -:  1849:  }
     -:  1850:
     -:  1851:  // Threads in Ready List
     -:  1852:  thread = osRtxInfo.thread.ready.thread_list;
     -:  1853:  while (thread != NULL) {
     -:  1854:    thread_next = thread->thread_next;
     -:  1855:    if ((((mode & osSafetyWithSameClass)  != 0U) &&
     -:  1856:         ((thread->attr >> osRtxAttrClass_Pos) == (uint8_t)safety_class)) ||
     -:  1857:        (((mode & osSafetyWithLowerClass) != 0U) &&
     -:  1858:         ((thread->attr >> osRtxAttrClass_Pos) <  (uint8_t)safety_class))) {
     -:  1859:      osRtxThreadListRemove(thread);
     -:  1860:      thread->state = osRtxThreadBlocked;
     -:  1861:      osRtxThreadDelayInsert(thread, osWaitForever);
     -:  1862:      EvrRtxThreadSuspended(thread);
     -:  1863:    }
     -:  1864:    thread = thread_next;
     -:  1865:  }
     -:  1866:
     -:  1867:  // Running Thread
     -:  1868:  thread = osRtxThreadGetRunning();
     -:  1869:  if ((thread != NULL) &&
     -:  1870:      ((((mode & osSafetyWithSameClass)  != 0U) &&
     -:  1871:        ((thread->attr >> osRtxAttrClass_Pos) == (uint8_t)safety_class)) ||
     -:  1872:       (((mode & osSafetyWithLowerClass) != 0U) &&
     -:  1873:        ((thread->attr >> osRtxAttrClass_Pos) <  (uint8_t)safety_class)))) {
     -:  1874:    if ((osRtxKernelGetState() == osRtxKernelRunning) &&
     -:  1875:        (osRtxInfo.thread.ready.thread_list != NULL)) {
     -:  1876:      thread->state = osRtxThreadBlocked;
     -:  1877:      osRtxThreadDelayInsert(thread, osWaitForever);
     -:  1878:      EvrRtxThreadSuspended(thread);
     -:  1879:      osRtxThreadSwitch(osRtxThreadListGet(&osRtxInfo.thread.ready));
     -:  1880:    } else {
     -:  1881:      EvrRtxThreadError(thread, (int32_t)osErrorResource);
     -:  1882:      //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:  1883:      return osErrorResource;
     -:  1884:    }
     -:  1885:  }
     -:  1886:
     -:  1887:  return osOK;
     -:  1888:#else
     -:  1889:  (void)safety_class;
     -:  1890:  (void)mode;
     -:  1891:  return osError;
     -:  1892:#endif
     -:  1893:}
     -:  1894:
     -:  1895:/// Resume execution of threads for specified safety classes.
     -:  1896:/// \note API identical to osThreadResumeClass
     -:  1897:static osStatus_t svcRtxThreadResumeClass (uint32_t safety_class, uint32_t mode) {
     -:  1898:#ifdef RTX_SAFETY_CLASS
     -:  1899:  os_thread_t *thread;
     -:  1900:  os_thread_t *thread_next;
     -:  1901:
     -:  1902:  // Check parameters
     -:  1903:  if (safety_class > 0x0FU) {
     -:  1904:    EvrRtxThreadError(NULL, (int32_t)osErrorParameter);
     -:  1905:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:  1906:    return osErrorParameter;
     -:  1907:  }
     -:  1908:
     -:  1909:  // Check running thread safety class (when called from thread)
     -:  1910:  thread = osRtxThreadGetRunning();
     -:  1911:  if ((thread != NULL) && IsSVCallIrq()) {
     -:  1912:    if ((((mode & osSafetyWithSameClass)  != 0U) &&
     -:  1913:         ((thread->attr >> osRtxAttrClass_Pos) < (uint8_t)safety_class)) ||
     -:  1914:        (((mode & osSafetyWithLowerClass) != 0U) &&
     -:  1915:         (((thread->attr >> osRtxAttrClass_Pos) + 1U) < (uint8_t)safety_class))) {
     -:  1916:      EvrRtxThreadError(NULL, (int32_t)osErrorSafetyClass);
     -:  1917:      //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:  1918:      return osErrorSafetyClass;
     -:  1919:    }
     -:  1920:  }
     -:  1921:
     -:  1922:  // Threads in Wait List
     -:  1923:  thread = osRtxInfo.thread.wait_list;
     -:  1924:  while (thread != NULL) {
     -:  1925:    thread_next = thread->delay_next;
     -:  1926:    if ((((mode & osSafetyWithSameClass)  != 0U) &&
     -:  1927:         ((thread->attr >> osRtxAttrClass_Pos) == (uint8_t)safety_class)) ||
     -:  1928:        (((mode & osSafetyWithLowerClass) != 0U) &&
     -:  1929:         ((thread->attr >> osRtxAttrClass_Pos) <  (uint8_t)safety_class))) {
     -:  1930:      // Wakeup Thread
     -:  1931:      osRtxThreadListRemove(thread);
     -:  1932:      osRtxThreadDelayRemove(thread);
     -:  1933:      osRtxThreadReadyPut(thread);
     -:  1934:      EvrRtxThreadResumed(thread);
     -:  1935:    }
     -:  1936:    thread = thread_next;
     -:  1937:  }
     -:  1938:
     -:  1939:  // Threads in Delay List
     -:  1940:  thread = osRtxInfo.thread.delay_list;
     -:  1941:  while (thread != NULL) {
     -:  1942:    thread_next = thread->delay_next;
     -:  1943:    if ((((mode & osSafetyWithSameClass)  != 0U) &&
     -:  1944:         ((thread->attr >> osRtxAttrClass_Pos) == (uint8_t)safety_class)) ||
     -:  1945:        (((mode & osSafetyWithLowerClass) != 0U) &&
     -:  1946:         ((thread->attr >> osRtxAttrClass_Pos) <  (uint8_t)safety_class))) {
     -:  1947:      // Wakeup Thread
     -:  1948:      osRtxThreadListRemove(thread);
     -:  1949:      osRtxThreadDelayRemove(thread);
     -:  1950:      osRtxThreadReadyPut(thread);
     -:  1951:      EvrRtxThreadResumed(thread);
     -:  1952:    }
     -:  1953:    thread = thread_next;
     -:  1954:  }
     -:  1955:
     -:  1956:  osRtxThreadDispatch(NULL);
     -:  1957:
     -:  1958:  return osOK;
     -:  1959:#else
     -:  1960:  (void)safety_class;
     -:  1961:  (void)mode;
     -:  1962:  return osError;
     -:  1963:#endif
     -:  1964:}
     -:  1965:
     -:  1966:/// Terminate execution of threads assigned to a specified MPU protected zone.
     -:  1967:/// \note API identical to osThreadTerminateZone
     -:  1968:static osStatus_t svcRtxThreadTerminateZone (uint32_t zone) {
     -:  1969:#ifdef RTX_EXECUTION_ZONE
     -:  1970:  os_thread_t *thread;
     -:  1971:  os_thread_t *thread_next;
     -:  1972:
     -:  1973:#ifdef RTX_THREAD_WATCHDOG
     -:  1974:  // Check Watchdog Alarm Flag
     -:  1975:  if (WatchdogAlarmFlag != 0U) {
     -:  1976:    EvrRtxThreadError(NULL, (int32_t)osErrorISR);
     -:  1977:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:  1978:    return osErrorISR;
     -:  1979:  }
     -:  1980:#endif
     -:  1981:
     -:  1982:  // Check parameters
     -:  1983:  if (zone > 0x3FU) {
     -:  1984:    EvrRtxThreadError(NULL, (int32_t)osErrorParameter);
     -:  1985:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:  1986:    return osErrorParameter;
     -:  1987:  }
     -:  1988:
     -:  1989:  // Threads in Wait List
     -:  1990:  thread = osRtxInfo.thread.wait_list;
     -:  1991:  while (thread != NULL) {
     -:  1992:    thread_next = thread->delay_next;
     -:  1993:    if (thread->zone == zone) {
     -:  1994:      osRtxThreadListRemove(thread);
     -:  1995:      osRtxThreadDelayRemove(thread);
     -:  1996:#ifdef RTX_THREAD_WATCHDOG
     -:  1997:      osRtxThreadWatchdogRemove(thread);
     -:  1998:#endif
     -:  1999:      osRtxMutexOwnerRelease(thread->mutex_list);
     -:  2000:      osRtxThreadJoinWakeup(thread);
     -:  2001:      osRtxThreadDestroy(thread);
     -:  2002:    }
     -:  2003:    thread = thread_next;
     -:  2004:  }
     -:  2005:
     -:  2006:  // Threads in Delay List
     -:  2007:  thread = osRtxInfo.thread.delay_list;
     -:  2008:  while (thread != NULL) {
     -:  2009:    thread_next = thread->delay_next;
     -:  2010:    if (thread->zone == zone) {
     -:  2011:      osRtxThreadListRemove(thread);
     -:  2012:      osRtxThreadDelayRemove(thread);
     -:  2013:#ifdef RTX_THREAD_WATCHDOG
     -:  2014:      osRtxThreadWatchdogRemove(thread);
     -:  2015:#endif
     -:  2016:      osRtxMutexOwnerRelease(thread->mutex_list);
     -:  2017:      osRtxThreadJoinWakeup(thread);
     -:  2018:      osRtxThreadDestroy(thread);
     -:  2019:    }
     -:  2020:    thread = thread_next;
     -:  2021:  }
     -:  2022:
     -:  2023:  // Threads in Ready List
     -:  2024:  thread = osRtxInfo.thread.ready.thread_list;
     -:  2025:  while (thread != NULL) {
     -:  2026:    thread_next = thread->thread_next;
     -:  2027:    if (thread->zone == zone) {
     -:  2028:      osRtxThreadListRemove(thread);
     -:  2029:#ifdef RTX_THREAD_WATCHDOG
     -:  2030:      osRtxThreadWatchdogRemove(thread);
     -:  2031:#endif
     -:  2032:      osRtxMutexOwnerRelease(thread->mutex_list);
     -:  2033:      osRtxThreadJoinWakeup(thread);
     -:  2034:      osRtxThreadDestroy(thread);
     -:  2035:    }
     -:  2036:    thread = thread_next;
     -:  2037:  }
     -:  2038:
     -:  2039:  // Running Thread
     -:  2040:  thread = osRtxThreadGetRunning();
     -:  2041:  if ((thread != NULL) && (thread->zone == zone)) {
     -:  2042:    if ((osRtxKernelGetState() != osRtxKernelRunning) ||
     -:  2043:        (osRtxInfo.thread.ready.thread_list == NULL)) {
     -:  2044:      osRtxThreadDispatch(NULL);
     -:  2045:      EvrRtxThreadError(thread, (int32_t)osErrorResource);
     -:  2046:      //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:  2047:      return osErrorResource;
     -:  2048:    }
     -:  2049:#ifdef RTX_THREAD_WATCHDOG
     -:  2050:    osRtxThreadWatchdogRemove(thread);
     -:  2051:#endif
     -:  2052:    osRtxMutexOwnerRelease(thread->mutex_list);
     -:  2053:    osRtxThreadJoinWakeup(thread);
     -:  2054:    // Switch to next Ready Thread
     -:  2055:    osRtxThreadSwitch(osRtxThreadListGet(&osRtxInfo.thread.ready));
     -:  2056:    // Update Stack Pointer
     -:  2057:    thread->sp = __get_PSP();
     -:  2058:#ifdef RTX_STACK_CHECK
     -:  2059:    // Check Stack usage
     -:  2060:    if (!osRtxThreadStackCheck(thread)) {
     -:  2061:      osRtxThreadSetRunning(osRtxInfo.thread.run.next);
     -:  2062:      (void)osRtxKernelErrorNotify(osRtxErrorStackOverflow, thread);
     -:  2063:    }
     -:  2064:#endif
     -:  2065:    // Mark running thread as deleted
     -:  2066:    osRtxThreadSetRunning(NULL);
     -:  2067:    // Destroy Thread
     -:  2068:    osRtxThreadDestroy(thread);
     -:  2069:  } else {
     -:  2070:    osRtxThreadDispatch(NULL);
     -:  2071:  }
     -:  2072:
     -:  2073:  return osOK;
     -:  2074:#else
     -:  2075:  (void)zone;
     -:  2076:  return osError;
     -:  2077:#endif
     -:  2078:}
     -:  2079:
     -:  2080:/// Set processor affinity mask of a thread.
     -:  2081:/// \note API identical to osThreadSetAffinityMask
     -:  2082:static osStatus_t svcRtxThreadSetAffinityMask (osThreadId_t thread_id, uint32_t affinity_mask) {
     -:  2083:  (void)thread_id;
     -:  2084:  (void)affinity_mask;
     -:  2085:  return osError;
     -:  2086:}
     -:  2087:
     -:  2088:/// Get current processor affinity mask of a thread.
     -:  2089:/// \note API identical to osThreadGetAffinityMask
     -:  2090:static uint32_t svcRtxThreadGetAffinityMask (osThreadId_t thread_id) {
     -:  2091:  (void)thread_id;
     -:  2092:  return 0U;
     -:  2093:}
     -:  2094:
     -:  2095:/// Get number of active threads.
     -:  2096:/// \note API identical to osThreadGetCount
     -:  2097:static uint32_t svcRtxThreadGetCount (void) {
     -:  2098:  const os_thread_t *thread;
     -:  2099:        uint32_t     count;
     -:  2100:
     -:  2101:  // Running Thread
     -:  2102:  count = 1U;
     -:  2103:
     -:  2104:  // Ready List
     -:  2105:  for (thread = osRtxInfo.thread.ready.thread_list;
     -:  2106:       thread != NULL; thread = thread->thread_next) {
     -:  2107:    count++;
     -:  2108:  }
     -:  2109:
     -:  2110:  // Delay List
     -:  2111:  for (thread = osRtxInfo.thread.delay_list;
     -:  2112:       thread != NULL; thread = thread->delay_next) {
     -:  2113:    count++;
     -:  2114:  }
     -:  2115:
     -:  2116:  // Wait List
     -:  2117:  for (thread = osRtxInfo.thread.wait_list;
     -:  2118:       thread != NULL; thread = thread->delay_next) {
     -:  2119:    count++;
     -:  2120:  }
     -:  2121:
     -:  2122:  EvrRtxThreadGetCount(count);
     -:  2123:
     -:  2124:  return count;
     -:  2125:}
     -:  2126:
     -:  2127:/// Enumerate active threads.
     -:  2128:/// \note API identical to osThreadEnumerate
     -:  2129:static uint32_t svcRtxThreadEnumerate (osThreadId_t *thread_array, uint32_t array_items) {
     -:  2130:  os_thread_t *thread;
     -:  2131:  uint32_t     count;
     -:  2132:
     -:  2133:  // Check parameters
     -:  2134:  if ((thread_array == NULL) || (array_items == 0U)) {
     -:  2135:    EvrRtxThreadEnumerate(thread_array, array_items, 0U);
     -:  2136:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:  2137:    return 0U;
     -:  2138:  }
     -:  2139:
     -:  2140:  // Running Thread
     -:  2141:  *thread_array = osRtxThreadGetRunning();
     -:  2142:   thread_array++;
     -:  2143:   count = 1U;
     -:  2144:
     -:  2145:  // Ready List
     -:  2146:  for (thread = osRtxInfo.thread.ready.thread_list;
     -:  2147:       (thread != NULL) && (count < array_items); thread = thread->thread_next) {
     -:  2148:    *thread_array = thread;
     -:  2149:     thread_array++;
     -:  2150:     count++;
     -:  2151:  }
     -:  2152:
     -:  2153:  // Delay List
     -:  2154:  for (thread = osRtxInfo.thread.delay_list;
     -:  2155:       (thread != NULL) && (count < array_items); thread = thread->delay_next) {
     -:  2156:    *thread_array = thread;
     -:  2157:     thread_array++;
     -:  2158:     count++;
     -:  2159:  }
     -:  2160:
     -:  2161:  // Wait List
     -:  2162:  for (thread = osRtxInfo.thread.wait_list;
     -:  2163:       (thread != NULL) && (count < array_items); thread = thread->delay_next) {
     -:  2164:    *thread_array = thread;
     -:  2165:     thread_array++;
     -:  2166:     count++;
     -:  2167:  }
     -:  2168:
     -:  2169:  EvrRtxThreadEnumerate(thread_array - count, array_items, count);
     -:  2170:
     -:  2171:  return count;
     -:  2172:}
     -:  2173:
     -:  2174:/// Set the specified Thread Flags of a thread.
     -:  2175:/// \note API identical to osThreadFlagsSet
     -:  2176:static uint32_t svcRtxThreadFlagsSet (osThreadId_t thread_id, uint32_t flags) {
     -:  2177:  os_thread_t       *thread = osRtxThreadId(thread_id);
     -:  2178:#ifdef RTX_SAFETY_CLASS
     -:  2179:  const os_thread_t *thread_running;
     -:  2180:#endif
     -:  2181:  uint32_t           thread_flags;
     -:  2182:  uint32_t           thread_flags0;
     -:  2183:
     -:  2184:  // Check parameters
     -:  2185:  if (!IsThreadPtrValid(thread) || (thread->id != osRtxIdThread) ||
     -:  2186:      ((flags & ~(((uint32_t)1U << osRtxThreadFlagsLimit) - 1U)) != 0U)) {
     -:  2187:    EvrRtxThreadFlagsError(thread, (int32_t)osErrorParameter);
     -:  2188:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:  2189:    return ((uint32_t)osErrorParameter);
     -:  2190:  }
     -:  2191:
     -:  2192:  // Check object state
     -:  2193:  if (thread->state == osRtxThreadTerminated) {
     -:  2194:    EvrRtxThreadFlagsError(thread, (int32_t)osErrorResource);
     -:  2195:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:  2196:    return ((uint32_t)osErrorResource);
     -:  2197:  }
     -:  2198:
     -:  2199:#ifdef RTX_SAFETY_CLASS
     -:  2200:  // Check running thread safety class
     -:  2201:  thread_running = osRtxThreadGetRunning();
     -:  2202:  if ((thread_running != NULL) &&
     -:  2203:      ((thread_running->attr >> osRtxAttrClass_Pos) < (thread->attr >> osRtxAttrClass_Pos))) {
     -:  2204:    EvrRtxThreadFlagsError(thread, (int32_t)osErrorSafetyClass);
     -:  2205:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:  2206:    return ((uint32_t)osErrorSafetyClass);
     -:  2207:  }
     -:  2208:#endif
     -:  2209:
     -:  2210:  // Set Thread Flags
     -:  2211:  thread_flags = ThreadFlagsSet(thread, flags);
     -:  2212:
     -:  2213:  // Check if Thread is waiting for Thread Flags
     -:  2214:  if (thread->state == osRtxThreadWaitingThreadFlags) {
     -:  2215:    thread_flags0 = ThreadFlagsCheck(thread, thread->wait_flags, thread->flags_options);
 #####:  2216:    if (thread_flags0 != 0U) {
 #####:  2217:      if ((thread->flags_options & osFlagsNoClear) == 0U) {
     -:  2218:        thread_flags = thread_flags0 & ~thread->wait_flags;
     -:  2219:      } else {
     -:  2220:        thread_flags = thread_flags0;
     -:  2221:      }
     -:  2222:      osRtxThreadWaitExit(thread, thread_flags0, TRUE);
 #####:  2223:      EvrRtxThreadFlagsWaitCompleted(thread->wait_flags, thread->flags_options, thread_flags0, thread);
     -:  2224:    }
     -:  2225:  }
     -:  2226:
     -:  2227:  EvrRtxThreadFlagsSetDone(thread, thread_flags);
     -:  2228:
     -:  2229:  return thread_flags;
 #####:  2230:}
     -:  2231:
     -:  2232:/// Clear the specified Thread Flags of current running thread.
     -:  2233:/// \note API identical to osThreadFlagsClear
     -:  2234:static uint32_t svcRtxThreadFlagsClear (uint32_t flags) {
     -:  2235:  os_thread_t *thread;
     -:  2236:  uint32_t     thread_flags;
     -:  2237:
     -:  2238:  // Check running thread
     -:  2239:  thread = osRtxThreadGetRunning();
     -:  2240:  if (thread == NULL) {
     -:  2241:    EvrRtxThreadFlagsError(NULL, osRtxErrorKernelNotRunning);
     -:  2242:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:  2243:    return ((uint32_t)osError);
     -:  2244:  }
     -:  2245:
     -:  2246:  // Check parameters
     -:  2247:  if ((flags & ~(((uint32_t)1U << osRtxThreadFlagsLimit) - 1U)) != 0U) {
     -:  2248:    EvrRtxThreadFlagsError(thread, (int32_t)osErrorParameter);
     -:  2249:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:  2250:    return ((uint32_t)osErrorParameter);
     -:  2251:  }
     -:  2252:
     -:  2253:  // Clear Thread Flags
     -:  2254:  thread_flags = ThreadFlagsClear(thread, flags);
     -:  2255:
     -:  2256:  EvrRtxThreadFlagsClearDone(thread_flags);
     -:  2257:
     -:  2258:  return thread_flags;
     -:  2259:}
     -:  2260:
     -:  2261:/// Get the current Thread Flags of current running thread.
     -:  2262:/// \note API identical to osThreadFlagsGet
     -:  2263:static uint32_t svcRtxThreadFlagsGet (void) {
     -:  2264:  const os_thread_t *thread;
     -:  2265:
     -:  2266:  // Check running thread
     -:  2267:  thread = osRtxThreadGetRunning();
     -:  2268:  if (thread == NULL) {
     -:  2269:    EvrRtxThreadFlagsGet(0U);
     -:  2270:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:  2271:    return 0U;
     -:  2272:  }
     -:  2273:
     -:  2274:  EvrRtxThreadFlagsGet(thread->thread_flags);
     -:  2275:
     -:  2276:  return thread->thread_flags;
     -:  2277:}
     -:  2278:
     -:  2279:/// Wait for one or more Thread Flags of the current running thread to become signaled.
     -:  2280:/// \note API identical to osThreadFlagsWait
     -:  2281:static uint32_t svcRtxThreadFlagsWait (uint32_t flags, uint32_t options, uint32_t timeout) {
     -:  2282:  os_thread_t *thread;
     -:  2283:  uint32_t     thread_flags;
     -:  2284:
     -:  2285:  // Check running thread
     -:  2286:  thread = osRtxThreadGetRunning();
     -:  2287:  if (thread == NULL) {
     -:  2288:    EvrRtxThreadFlagsError(NULL, osRtxErrorKernelNotRunning);
     -:  2289:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:  2290:    return ((uint32_t)osError);
     -:  2291:  }
     -:  2292:
     -:  2293:  // Check parameters
     -:  2294:  if ((flags & ~(((uint32_t)1U << osRtxThreadFlagsLimit) - 1U)) != 0U) {
     -:  2295:    EvrRtxThreadFlagsError(thread, (int32_t)osErrorParameter);
     -:  2296:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:  2297:    return ((uint32_t)osErrorParameter);
     -:  2298:  }
     -:  2299:
     -:  2300:  // Check Thread Flags
     -:  2301:  thread_flags = ThreadFlagsCheck(thread, flags, options);
     -:  2302:  if (thread_flags != 0U) {
     -:  2303:    EvrRtxThreadFlagsWaitCompleted(flags, options, thread_flags, thread);
     -:  2304:  } else {
     -:  2305:    // Check if timeout is specified
     -:  2306:    if (timeout != 0U) {
     -:  2307:      // Store waiting flags and options
 #####:  2308:      EvrRtxThreadFlagsWaitPending(flags, options, timeout);
 #####:  2309:      thread->wait_flags = flags;
     -:  2310:      thread->flags_options = (uint8_t)options;
     -:  2311:      // Suspend current Thread
     -:  2312:      if (!osRtxThreadWaitEnter(osRtxThreadWaitingThreadFlags, timeout)) {
     -:  2313:        EvrRtxThreadFlagsWaitTimeout(thread);
     -:  2314:      }
     -:  2315:      thread_flags = (uint32_t)osErrorTimeout;
     -:  2316:    } else {
     -:  2317:      EvrRtxThreadFlagsWaitNotCompleted(flags, options);
     -:  2318:      thread_flags = (uint32_t)osErrorResource;
     -:  2319:    }
     -:  2320:  }
     -:  2321:  return thread_flags;
     -:  2322:}
     -:  2323:
     -:  2324://  Service Calls definitions
     -:  2325://lint ++flb "Library Begin" [MISRA Note 11]
     1:  2326:SVC0_3 (ThreadNew,           osThreadId_t,    osThreadFunc_t, void *, const osThreadAttr_t *)
     -:  2327:SVC0_1 (ThreadGetName,       const char *,    osThreadId_t)
     -:  2328:SVC0_1 (ThreadGetClass,      uint32_t,        osThreadId_t)
     -:  2329:SVC0_1 (ThreadGetZone,       uint32_t,        osThreadId_t)
 #####:  2330:SVC0_0 (ThreadGetId,         osThreadId_t)
     -:  2331:SVC0_1 (ThreadGetState,      osThreadState_t, osThreadId_t)
     -:  2332:SVC0_1 (ThreadGetStackSize,  uint32_t,        osThreadId_t)
     -:  2333:SVC0_1 (ThreadGetStackSpace, uint32_t,        osThreadId_t)
     -:  2334:SVC0_2 (ThreadSetPriority,   osStatus_t,      osThreadId_t, osPriority_t)
     -:  2335:SVC0_1 (ThreadGetPriority,   osPriority_t,    osThreadId_t)
     -:  2336:SVC0_0 (ThreadYield,         osStatus_t)
     -:  2337:SVC0_1 (ThreadSuspend,       osStatus_t,      osThreadId_t)
     -:  2338:SVC0_1 (ThreadResume,        osStatus_t,      osThreadId_t)
     -:  2339:SVC0_1 (ThreadDetach,        osStatus_t,      osThreadId_t)
     -:  2340:SVC0_1 (ThreadJoin,          osStatus_t,      osThreadId_t)
     1:  2341:SVC0_0N(ThreadExit,          void)
     -:  2342:SVC0_1 (ThreadTerminate,     osStatus_t,      osThreadId_t)
     -:  2343:SVC0_1 (ThreadFeedWatchdog,      osStatus_t,  uint32_t)
     -:  2344:SVC0_0 (ThreadProtectPrivileged, osStatus_t)
 #####:  2345:SVC0_2 (ThreadSuspendClass,      osStatus_t,  uint32_t, uint32_t)
     -:  2346:SVC0_2 (ThreadResumeClass,       osStatus_t,  uint32_t, uint32_t)
     -:  2347:SVC0_2 (ThreadSetAffinityMask,   osStatus_t,  osThreadId_t, uint32_t)
     -:  2348:SVC0_1 (ThreadGetAffinityMask,   uint32_t,    osThreadId_t)
     -:  2349:SVC0_0 (ThreadGetCount,      uint32_t)
     -:  2350:SVC0_2 (ThreadEnumerate,     uint32_t,        osThreadId_t *, uint32_t)
 #####:  2351:SVC0_2 (ThreadFlagsSet,      uint32_t,        osThreadId_t, uint32_t)
     -:  2352:SVC0_1 (ThreadFlagsClear,    uint32_t,        uint32_t)
     -:  2353:SVC0_0 (ThreadFlagsGet,      uint32_t)
     -:  2354:SVC0_3 (ThreadFlagsWait,     uint32_t,        uint32_t, uint32_t, uint32_t)
     -:  2355://lint --flb "Library End"
     -:  2356:
     -:  2357:
     -:  2358://  ==== ISR Calls ====
     -:  2359:
     -:  2360:/// Set the specified Thread Flags of a thread.
     -:  2361:/// \note API identical to osThreadFlagsSet
     -:  2362:__STATIC_INLINE
     -:  2363:uint32_t isrRtxThreadFlagsSet (osThreadId_t thread_id, uint32_t flags) {
     -:  2364:  os_thread_t *thread = osRtxThreadId(thread_id);
     -:  2365:  uint32_t     thread_flags;
     -:  2366:
     -:  2367:  // Check parameters
     -:  2368:  if (!IsThreadPtrValid(thread) || (thread->id != osRtxIdThread) ||
     -:  2369:      ((flags & ~(((uint32_t)1U << osRtxThreadFlagsLimit) - 1U)) != 0U)) {
     -:  2370:    EvrRtxThreadFlagsError(thread, (int32_t)osErrorParameter);
     -:  2371:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:  2372:    return ((uint32_t)osErrorParameter);
     -:  2373:  }
     -:  2374:
     -:  2375:  // Check object state
     -:  2376:  if (thread->state == osRtxThreadTerminated) {
     -:  2377:    EvrRtxThreadFlagsError(thread, (int32_t)osErrorResource);
     -:  2378:    //lint -e{904} "Return statement before end of function" [MISRA Note 1]
     -:  2379:    return ((uint32_t)osErrorResource);
     -:  2380:  }
     -:  2381:
     -:  2382:  // Set Thread Flags
     -:  2383:  thread_flags = ThreadFlagsSet(thread, flags);
     -:  2384:
     -:  2385:  // Register post ISR processing
     -:  2386:  osRtxPostProcess(osRtxObject(thread));
     -:  2387:
 #####:  2388:  EvrRtxThreadFlagsSetDone(thread, thread_flags);
     -:  2389:
     -:  2390:  return thread_flags;
     -:  2391:}
     -:  2392:
     -:  2393:
     -:  2394://  ==== Library functions ====
     -:  2395:
     -:  2396:/// RTOS Thread Before Free Hook.
     -:  2397://lint -esym(759,osRtxThreadBeforeFree) "Prototype in header"
     -:  2398://lint -esym(765,osRtxThreadBeforeFree) "Global scope (can be overridden)"
     -:  2399:__WEAK void osRtxThreadBeforeFree (os_thread_t *thread) {
     -:  2400:  (void)thread;
     -:  2401:}
     -:  2402:
     -:  2403:/// Thread startup (Idle and Timer Thread).
     -:  2404:/// \return true - success, false - failure.
     1:  2405:bool_t osRtxThreadStartup (void) {
     -:  2406:  bool_t ret = FALSE;
     -:  2407:
     -:  2408:  // Create Idle Thread
     1:  2409:  osRtxInfo.thread.idle = osRtxThreadId(
     1:  2410:    svcRtxThreadNew(osRtxIdleThread, NULL, osRtxConfig.idle_thread_attr)
     -:  2411:  );
     -:  2412:
     -:  2413:  // Create Timer Thread
     1:  2414:  if (osRtxConfig.timer_setup != NULL) {
     1:  2415:    if (osRtxConfig.timer_setup() == 0) {
     1:  2416:      osRtxInfo.timer.thread = osRtxThreadId(
     1:  2417:        svcRtxThreadNew(osRtxConfig.timer_thread, osRtxInfo.timer.mq, osRtxConfig.timer_thread_attr)
     -:  2418:      );
     1:  2419:      if (osRtxInfo.timer.thread != NULL) {
     -:  2420:        ret = TRUE;
     -:  2421:      }
     -:  2422:    }
     -:  2423:  } else {
     -:  2424:    ret = TRUE;
     -:  2425:  }
     -:  2426:
     1:  2427:  return ret;
     -:  2428:}
     -:  2429:
     -:  2430:
     -:  2431://  ==== Public API ====
     -:  2432:
     -:  2433:/// Create a thread and add it to Active Threads.
     1:  2434:osThreadId_t osThreadNew (osThreadFunc_t func, void *argument, const osThreadAttr_t *attr) {
     -:  2435:  osThreadId_t thread_id;
     -:  2436:
     1:  2437:  EvrRtxThreadNew(func, argument, attr);
     1:  2438:  if (IsException() || IsIrqMasked()) {
 #####:  2439:    EvrRtxThreadError(NULL, (int32_t)osErrorISR);
     -:  2440:    thread_id = NULL;
     -:  2441:  } else {
     -:  2442:    thread_id = __svcThreadNew(func, argument, attr);
     -:  2443:  }
 #####:  2444:  return thread_id;
     -:  2445:}
     -:  2446:
     -:  2447:/// Get name of a thread.
     -:  2448:const char *osThreadGetName (osThreadId_t thread_id) {
     -:  2449:  const char *name;
     -:  2450:
 #####:  2451:  if (IsException() || IsIrqMasked()) {
     -:  2452:    name = svcRtxThreadGetName(thread_id);
     -:  2453:  } else {
     -:  2454:    name =  __svcThreadGetName(thread_id);
     -:  2455:  }
 #####:  2456:  return name;
     -:  2457:}
     -:  2458:
     -:  2459:/// Get safety class of a thread.
     -:  2460:uint32_t osThreadGetClass (osThreadId_t thread_id) {
     -:  2461:  uint32_t safety_class;
     -:  2462:
     -:  2463:  if (IsException() || IsIrqMasked()) {
     -:  2464:    safety_class = svcRtxThreadGetClass(thread_id);
     -:  2465:  } else {
     -:  2466:    safety_class =  __svcThreadGetClass(thread_id);
     -:  2467:  }
 #####:  2468:  return safety_class;
     -:  2469:}
     -:  2470:
     -:  2471:/// Get zone of a thread.
     -:  2472:uint32_t osThreadGetZone (osThreadId_t thread_id) {
     -:  2473:  uint32_t zone;
     -:  2474:
     -:  2475:  if (IsException() || IsIrqMasked()) {
     -:  2476:    zone = svcRtxThreadGetZone(thread_id);
     -:  2477:  } else {
     -:  2478:    zone =  __svcThreadGetZone(thread_id);
     -:  2479:  }
     -:  2480:  return zone;
     -:  2481:}
     -:  2482:
     -:  2483:/// Return the thread ID of the current running thread.
 #####:  2484:osThreadId_t osThreadGetId (void) {
     -:  2485:  osThreadId_t thread_id;
     -:  2486:
 #####:  2487:  if (IsException() || IsIrqMasked()) {
     -:  2488:    thread_id = svcRtxThreadGetId();
     -:  2489:  } else {
     -:  2490:    thread_id =  __svcThreadGetId();
     -:  2491:  }
 #####:  2492:  return thread_id;
     -:  2493:}
     -:  2494:
     -:  2495:/// Get current thread state of a thread.
     -:  2496:osThreadState_t osThreadGetState (osThreadId_t thread_id) {
     -:  2497:  osThreadState_t state;
     -:  2498:
     -:  2499:  if (IsException() || IsIrqMasked()) {
     -:  2500:    EvrRtxThreadGetState(thread_id, osThreadError);
     -:  2501:    state = osThreadError;
     -:  2502:  } else {
     -:  2503:    state = __svcThreadGetState(thread_id);
     -:  2504:  }
     -:  2505:  return state;
     -:  2506:}
     -:  2507:
     -:  2508:/// Get stack size of a thread.
     -:  2509:uint32_t osThreadGetStackSize (osThreadId_t thread_id) {
     -:  2510:  uint32_t stack_size;
     -:  2511:
     -:  2512:  if (IsException() || IsIrqMasked()) {
     -:  2513:    EvrRtxThreadGetStackSize(thread_id, 0U);
     -:  2514:    stack_size = 0U;
     -:  2515:  } else {
     -:  2516:    stack_size = __svcThreadGetStackSize(thread_id);
     -:  2517:  }
     -:  2518:  return stack_size;
     -:  2519:}
     -:  2520:
     -:  2521:/// Get available stack space of a thread based on stack watermark recording during execution.
     -:  2522:uint32_t osThreadGetStackSpace (osThreadId_t thread_id) {
     -:  2523:  uint32_t stack_space;
     -:  2524:
     -:  2525:  if (IsException() || IsIrqMasked()) {
     -:  2526:    EvrRtxThreadGetStackSpace(thread_id, 0U);
     -:  2527:    stack_space = 0U;
     -:  2528:  } else {
     -:  2529:    stack_space = __svcThreadGetStackSpace(thread_id);
     -:  2530:  }
     -:  2531:  return stack_space;
     -:  2532:}
     -:  2533:
     -:  2534:/// Change priority of a thread.
     -:  2535:osStatus_t osThreadSetPriority (osThreadId_t thread_id, osPriority_t priority) {
     -:  2536:  osStatus_t status;
     -:  2537:
     -:  2538:  EvrRtxThreadSetPriority(thread_id, priority);
     -:  2539:  if (IsException() || IsIrqMasked()) {
     -:  2540:    EvrRtxThreadError(thread_id, (int32_t)osErrorISR);
     -:  2541:    status = osErrorISR;
     -:  2542:  } else {
     -:  2543:    status = __svcThreadSetPriority(thread_id, priority);
     -:  2544:  }
     -:  2545:  return status;
     -:  2546:}
     -:  2547:
     -:  2548:/// Get current priority of a thread.
     -:  2549:osPriority_t osThreadGetPriority (osThreadId_t thread_id) {
     -:  2550:  osPriority_t priority;
     -:  2551:
     -:  2552:  if (IsException() || IsIrqMasked()) {
     -:  2553:    EvrRtxThreadGetPriority(thread_id, osPriorityError);
     -:  2554:    priority = osPriorityError;
     -:  2555:  } else {
     -:  2556:    priority = __svcThreadGetPriority(thread_id);
     -:  2557:  }
     -:  2558:  return priority;
     -:  2559:}
     -:  2560:
     -:  2561:/// Pass control to next thread that is in state READY.
     -:  2562:osStatus_t osThreadYield (void) {
     -:  2563:  osStatus_t status;
     -:  2564:
     -:  2565:  EvrRtxThreadYield();
     -:  2566:  if (IsException() || IsIrqMasked()) {
     -:  2567:    EvrRtxThreadError(NULL, (int32_t)osErrorISR);
     -:  2568:    status = osErrorISR;
     -:  2569:  } else {
     -:  2570:    status = __svcThreadYield();
     -:  2571:  }
     -:  2572:  return status;
     -:  2573:}
     -:  2574:
     -:  2575:/// Suspend execution of a thread.
     -:  2576:osStatus_t osThreadSuspend (osThreadId_t thread_id) {
     -:  2577:  osStatus_t status;
     -:  2578:
     -:  2579:  EvrRtxThreadSuspend(thread_id);
 #####:  2580:  if (IsException() || IsIrqMasked()) {
     -:  2581:    EvrRtxThreadError(thread_id, (int32_t)osErrorISR);
     -:  2582:    status = osErrorISR;
     -:  2583:  } else {
     -:  2584:    status = __svcThreadSuspend(thread_id);
     -:  2585:  }
 #####:  2586:  return status;
     -:  2587:}
     -:  2588:
     -:  2589:/// Resume execution of a thread.
     -:  2590:osStatus_t osThreadResume (osThreadId_t thread_id) {
     -:  2591:  osStatus_t status;
     -:  2592:
     -:  2593:  EvrRtxThreadResume(thread_id);
     -:  2594:  if (IsException() || IsIrqMasked()) {
     -:  2595:    EvrRtxThreadError(thread_id, (int32_t)osErrorISR);
     -:  2596:    status = osErrorISR;
     -:  2597:  } else {
     -:  2598:    status = __svcThreadResume(thread_id);
     -:  2599:  }
     -:  2600:  return status;
     -:  2601:}
     -:  2602:
     -:  2603:/// Detach a thread (thread storage can be reclaimed when thread terminates).
     -:  2604:osStatus_t osThreadDetach (osThreadId_t thread_id) {
     -:  2605:  osStatus_t status;
     -:  2606:
     -:  2607:  EvrRtxThreadDetach(thread_id);
     -:  2608:  if (IsException() || IsIrqMasked()) {
     -:  2609:    EvrRtxThreadError(thread_id, (int32_t)osErrorISR);
     -:  2610:    status = osErrorISR;
     -:  2611:  } else {
     -:  2612:    status = __svcThreadDetach(thread_id);
     -:  2613:  }
     -:  2614:  return status;
     -:  2615:}
     -:  2616:
     -:  2617:/// Wait for specified thread to terminate.
     -:  2618:osStatus_t osThreadJoin (osThreadId_t thread_id) {
     -:  2619:  osStatus_t status;
     -:  2620:
     -:  2621:  EvrRtxThreadJoin(thread_id);
     -:  2622:  if (IsException() || IsIrqMasked()) {
     -:  2623:    EvrRtxThreadError(thread_id, (int32_t)osErrorISR);
     -:  2624:    status = osErrorISR;
     -:  2625:  } else {
     -:  2626:    status = __svcThreadJoin(thread_id);
     -:  2627:  }
     -:  2628:  return status;
     -:  2629:}
     -:  2630:
     -:  2631:/// Terminate execution of current running thread.
     -:  2632:__NO_RETURN void osThreadExit (void) {
     1:  2633:  EvrRtxThreadExit();
     -:  2634:  __svcThreadExit();
 #####:  2635:  EvrRtxThreadError(NULL, (int32_t)osError);
 #####:  2636:  for (;;) {}
     -:  2637:}
     -:  2638:
     -:  2639:/// Terminate execution of a thread.
     -:  2640:osStatus_t osThreadTerminate (osThreadId_t thread_id) {
     -:  2641:  osStatus_t status;
     -:  2642:
     -:  2643:  EvrRtxThreadTerminate(thread_id);
     -:  2644:  if (IsException() || IsIrqMasked()) {
     -:  2645:    EvrRtxThreadError(thread_id, (int32_t)osErrorISR);
     -:  2646:    status = osErrorISR;
     -:  2647:  } else {
     -:  2648:    status = __svcThreadTerminate(thread_id);
     -:  2649:  }
     -:  2650:  return status;
     -:  2651:}
     -:  2652:
     -:  2653:/// Feed watchdog of the current running thread.
     -:  2654:osStatus_t osThreadFeedWatchdog (uint32_t ticks) {
     -:  2655:  osStatus_t status;
     -:  2656:
     -:  2657:  EvrRtxThreadFeedWatchdog(ticks);
     -:  2658:  if (IsException() || IsIrqMasked()) {
     -:  2659:    EvrRtxThreadError(NULL, (int32_t)osErrorISR);
     -:  2660:    status = osErrorISR;
     -:  2661:  } else {
     -:  2662:    status = __svcThreadFeedWatchdog(ticks);
     -:  2663:  }
     -:  2664:  return status;
     -:  2665:}
     -:  2666:
     -:  2667:/// Protect the creation of privileged threads.
     -:  2668:osStatus_t osThreadProtectPrivileged (void) {
     -:  2669:  osStatus_t status;
     -:  2670:
     -:  2671:  EvrRtxThreadProtectPrivileged();
     -:  2672:  if (IsException() || IsIrqMasked()) {
     -:  2673:    EvrRtxThreadError(NULL, (int32_t)osErrorISR);
     -:  2674:    status = osErrorISR;
     -:  2675:  } else {
     -:  2676:    status = __svcThreadProtectPrivileged();
     -:  2677:  }
     -:  2678:  return status;
     -:  2679:}
     -:  2680:
     -:  2681:/// Suspend execution of threads for specified safety classes.
     -:  2682:osStatus_t osThreadSuspendClass (uint32_t safety_class, uint32_t mode) {
     -:  2683:  osStatus_t status;
     -:  2684:
     -:  2685:  EvrRtxThreadSuspendClass(safety_class, mode);
     -:  2686:  if (IsException() || IsIrqMasked()) {
     -:  2687:    if (IsTickIrq(osRtxInfo.tick_irqn)) {
     -:  2688:      status = svcRtxThreadSuspendClass(safety_class, mode);
     -:  2689:    } else {
     -:  2690:      EvrRtxThreadError(NULL, (int32_t)osErrorISR);
     -:  2691:      status = osErrorISR;
     -:  2692:    }
     -:  2693:  } else {
     -:  2694:    status   =  __svcThreadSuspendClass(safety_class, mode);
     -:  2695:  }
 #####:  2696:  return status;
     -:  2697:}
     -:  2698:
     -:  2699:/// Resume execution of threads for specified safety classes.
     -:  2700:osStatus_t osThreadResumeClass (uint32_t safety_class, uint32_t mode) {
     -:  2701:  osStatus_t status;
     -:  2702:
     -:  2703:  EvrRtxThreadResumeClass(safety_class, mode);
     -:  2704:  if (IsException() || IsIrqMasked()) {
     -:  2705:    if (IsTickIrq(osRtxInfo.tick_irqn)) {
     -:  2706:      status = svcRtxThreadResumeClass(safety_class, mode);
     -:  2707:    } else {
     -:  2708:      EvrRtxThreadError(NULL, (int32_t)osErrorISR);
     -:  2709:      status = osErrorISR;
     -:  2710:    }
     -:  2711:  } else {
     -:  2712:    status   =  __svcThreadResumeClass(safety_class, mode);
     -:  2713:  }
 #####:  2714:  return status;
     -:  2715:}
     -:  2716:
     -:  2717:/// Terminate execution of threads assigned to a specified MPU protected zone.
     -:  2718:osStatus_t osThreadTerminateZone (uint32_t zone) {
     -:  2719:  osStatus_t status;
     -:  2720:
     -:  2721:  EvrRtxThreadTerminateZone(zone);
     -:  2722:  if (IsException() || IsIrqMasked()) {
 #####:  2723:    if (IsFault() || IsSVCallIrq() || IsPendSvIrq() || IsTickIrq(osRtxInfo.tick_irqn)) {
     -:  2724:      status = svcRtxThreadTerminateZone(zone);
     -:  2725:    } else {
 #####:  2726:      EvrRtxThreadError(NULL, (int32_t)osErrorISR);
     -:  2727:      status = osErrorISR;
     -:  2728:    }
     -:  2729:  } else {
 #####:  2730:    EvrRtxThreadError(osRtxThreadGetRunning(), (int32_t)osError);
     -:  2731:    status   = osError;
     -:  2732:  }
 #####:  2733:  return status;
     -:  2734:}
     -:  2735:
     -:  2736:/// Set processor affinity mask of a thread.
     -:  2737:osStatus_t osThreadSetAffinityMask (osThreadId_t thread_id, uint32_t affinity_mask) {
     -:  2738:  osStatus_t status;
     -:  2739:
     -:  2740:  if (IsException() || IsIrqMasked()) {
     -:  2741:    status = osErrorISR;
     -:  2742:  } else {
     -:  2743:    status = __svcThreadSetAffinityMask(thread_id, affinity_mask);
     -:  2744:  }
     -:  2745:  return status;
     -:  2746:}
     -:  2747:
     -:  2748:/// Get current processor affinity mask of a thread.
     -:  2749:uint32_t osThreadGetAffinityMask (osThreadId_t thread_id) {
     -:  2750:  uint32_t affinity_mask;
     -:  2751:
     -:  2752:  if (IsException() || IsIrqMasked()) {
     -:  2753:    affinity_mask = 0U;
     -:  2754:  } else {
     -:  2755:    affinity_mask = __svcThreadGetAffinityMask(thread_id);
     -:  2756:  }
 #####:  2757:  return affinity_mask;
     -:  2758:}
     -:  2759:
     -:  2760:/// Get number of active threads.
     -:  2761:uint32_t osThreadGetCount (void) {
     -:  2762:  uint32_t count;
     -:  2763:
     -:  2764:  if (IsException() || IsIrqMasked()) {
     -:  2765:    EvrRtxThreadGetCount(0U);
     -:  2766:    count = 0U;
     -:  2767:  } else {
     -:  2768:    count = __svcThreadGetCount();
     -:  2769:  }
     -:  2770:  return count;
     -:  2771:}
     -:  2772:
     -:  2773:/// Enumerate active threads.
     -:  2774:uint32_t osThreadEnumerate (osThreadId_t *thread_array, uint32_t array_items) {
     -:  2775:  uint32_t count;
     -:  2776:
     -:  2777:  if (IsException() || IsIrqMasked()) {
     -:  2778:    EvrRtxThreadEnumerate(thread_array, array_items, 0U);
     -:  2779:    count = 0U;
     -:  2780:  } else {
     -:  2781:    count = __svcThreadEnumerate(thread_array, array_items);
     -:  2782:  }
     -:  2783:  return count;
     -:  2784:}
     -:  2785:
     -:  2786:/// Set the specified Thread Flags of a thread.
     -:  2787:uint32_t osThreadFlagsSet (osThreadId_t thread_id, uint32_t flags) {
     -:  2788:  uint32_t thread_flags;
     -:  2789:
     -:  2790:  EvrRtxThreadFlagsSet(thread_id, flags);
     -:  2791:  if (IsException() || IsIrqMasked()) {
     -:  2792:    thread_flags = isrRtxThreadFlagsSet(thread_id, flags);
     -:  2793:  } else {
     -:  2794:    thread_flags =  __svcThreadFlagsSet(thread_id, flags);
     -:  2795:  }
 #####:  2796:  return thread_flags;
     -:  2797:}
     -:  2798:
     -:  2799:/// Clear the specified Thread Flags of current running thread.
     -:  2800:uint32_t osThreadFlagsClear (uint32_t flags) {
     -:  2801:  uint32_t thread_flags;
     -:  2802:
     -:  2803:  EvrRtxThreadFlagsClear(flags);
     -:  2804:  if (IsException() || IsIrqMasked()) {
     -:  2805:    EvrRtxThreadFlagsError(NULL, (int32_t)osErrorISR);
     -:  2806:    thread_flags = (uint32_t)osErrorISR;
     -:  2807:  } else {
     -:  2808:    thread_flags = __svcThreadFlagsClear(flags);
     -:  2809:  }
     -:  2810:  return thread_flags;
     -:  2811:}
     -:  2812:
     -:  2813:/// Get the current Thread Flags of current running thread.
     -:  2814:uint32_t osThreadFlagsGet (void) {
     -:  2815:  uint32_t thread_flags;
     -:  2816:
     -:  2817:  if (IsException() || IsIrqMasked()) {
     -:  2818:    EvrRtxThreadFlagsGet(0U);
     -:  2819:    thread_flags = 0U;
     -:  2820:  } else {
     -:  2821:    thread_flags = __svcThreadFlagsGet();
     -:  2822:  }
     -:  2823:  return thread_flags;
     -:  2824:}
     -:  2825:
     -:  2826:/// Wait for one or more Thread Flags of the current running thread to become signaled.
     -:  2827:uint32_t osThreadFlagsWait (uint32_t flags, uint32_t options, uint32_t timeout) {
     -:  2828:  uint32_t thread_flags;
     -:  2829:
     -:  2830:  EvrRtxThreadFlagsWait(flags, options, timeout);
     -:  2831:  if (IsException() || IsIrqMasked()) {
     -:  2832:    EvrRtxThreadFlagsError(NULL, (int32_t)osErrorISR);
     -:  2833:    thread_flags = (uint32_t)osErrorISR;
     -:  2834:  } else {
     -:  2835:    thread_flags = __svcThreadFlagsWait(flags, options, timeout);
     -:  2836:  }
     -:  2837:  return thread_flags;
     -:  2838:}
